using EnergyModelsGeography
const EMG = EnergyModelsGeography
const EMGExt = Base.get_extension(EMRH, :EMGExt)

@testset "Identification - Area" begin
    # Create the individual resources
    H2_hp = ResourceCarrier("H2_hp", 0.0)
    H2_lp = ResourceCarrier("H2_lp", 0.0)
    el = ResourceCarrier("Power", 0.0)
    co2 = ResourceEmit("co2", 1.0)
    resources = [H2_hp, H2_lp, el, co2]

    # Create the profiles
    n_op = 15
    dur_op = ones(n_op)
    prof_1 = OperationalProfile(rand(n_op))
    prof_2 = OperationalProfile(rand(n_op))

    # Create the Transmission corridors
    av = GeoAvailability(1, resources)
    ùí© = EMB.Node[av]
    a_1 = RefArea(2, "RefArea", 1, 1, av)
    a_2 = LimitedExchangeArea(1, "LEArea", 1, 1, av, Dict(H2_hp => prof_1, el => prof_2))
    ùíú = [a_1, a_2]

    @testset "Path creation" begin
        # Test of all potential node input from EMRH as called through the function
        # - _find_update_paths(x::Union{AbstractElement, Resource, RecHorEnergyModel})

        # The individual function flow is included on top

        # Test of a transmission corridor with two modes
        # - _find_update_paths(field::AbstractElement, current_path::Vector{Any}, all_paths::Vector{Any})
        @test issetequal(
            EMRH._find_update_paths(a_1),
            [
                [:node, EMRH.ElementPath()],
            ],
        )

        # Test of a transmission corridor with a pipeline mode
        # - _find_update_paths(field::AbstractElement, current_path::Vector{Any}, all_paths::Vector{Any})
        # - _find_update_paths(field::AbstractDict, current_path::Vector{Any}, all_paths::Vector{Any})
        # - _dict_key(key::Resource)
        # - _find_update_paths(field::OperationalProfile, current_path::Vector{Any}, all_paths::Vector{Any})
        @test issetequal(
            EMRH._find_update_paths(a_2),
            [
                [:node, EMRH.ElementPath()],
                [:limit, el, EMRH.OperPath()],
                [:limit, H2_hp, EMRH.OperPath()],
            ],
        )
    end

    @testset "Lens creation" begin
        # Create the lenses
        lens_dict = EMRH._create_lens_dict(ùíú)

        # Test that the lenses are created for all transmission corridors
        # - _create_lens_dict(ùí≥::Vector{<:AbstractElement}
        # - _create_lens_dict(x::Union{AbstractElement, RecHorEnergyModel})
        # - _create_lens_for_field(field_id::Vector{<:Any})
        @test all(haskey(lens_dict, a) for a ‚àà ùíú)

        # Test that the individual lenses are correctly created and working
        @test lens_dict[a_1][[:node, EMRH.ElementPath()]](a_1) == av

        @test lens_dict[a_2][[:node, EMRH.ElementPath()]](a_2) == av
        @test lens_dict[a_2][[:limit, H2_hp, EMRH.OperPath()]](a_2) == prof_1
        @test lens_dict[a_2][[:limit, el, EMRH.OperPath()]](a_2) == prof_2
    end

    @testset "Reset functionality" begin
        # Create an operational modeltype and the time structure
        modeltype = RecHorOperationalModel(
            Dict(co2 => FixedProfile(100)),
            Dict(co2 => FixedProfile(60)),
            co2,
        )

        # Create the update type
        ùí∞ = EMRH._create_updatetype(modeltype)
        EMRH._add_elements!(ùí∞, ùí©)
        EMRH._add_elements!(ùí∞, ùíú)

        # Create all time related parameters
        ùíØ = TwoLevel(1, 1, SimpleTimes(dur_op))
        opers = collect(ùíØ)
        ‚Ñã = PeriodHorizons(dur_op, 4, 2)
        ùíΩ = first(‚Ñã)
        ùíØ·µ£‚Çï = TwoLevel(1, sum(durations(ùíΩ)), SimpleTimes(durations(ùíΩ)))
        ind_impl = indices_implementation(ùíΩ)
        opers_opt = opers[indices_optimization(ùíΩ)]
        opers_impl = opers[ind_impl]
        opers_impl·µ£‚Çï = collect(ùíØ·µ£‚Çï)[1:length(ind_impl)]

        # Test that the individual reset types functions are working
        # All functions are located within the file src/structures/reset.jl
        ùíÆ·µõ·µâ·∂ú = EMRH.get_sub_elements_vec(ùí∞)
        @test isa(ùíÆ·µõ·µâ·∂ú[2], Vector{EMGExt.AreaSub})
        @test EMRH.get_sub_ele(ùí∞, Area) == ùí∞.elements[2]
        @test EMRH.get_sub_ele(ùíÆ·µõ·µâ·∂ú, Area) == ùí∞.elements[2]

        # Test the resets (ElementReset)
        reset_area = EMRH.resets(ùíÆ·µõ·µâ·∂ú[2][1])
        @test isa(reset_area[1], EMRH.ElementReset)

        reset_area = EMRH.resets(ùíÆ·µõ·µâ·∂ú[2][2])
        @test isa(reset_area[1], EMRH.ElementReset)
        @test reset_area[1].lens(a_2) == av
        @test reset_area[1].val == av

        # Test that the reset are working
        # - _update_update_case!(ùí∞, opers_opt, ùíØ·µ£‚Çï)
        # - _update_case_types!
        # - reset_field
        EMRH._update_update_case!(ùí∞, opers_opt, ùíØ·µ£‚Çï)

        # Extract the resetted nodes and areas
        ùí© ≥ = [s.new for s ‚àà ùíÆ·µõ·µâ·∂ú[1]]
        ùíú ≥ = [s.new for s ‚àà ùíÆ·µõ·µâ·∂ú[2]]
        @test get_elements_vec(ùí∞) == Vector[ùí© ≥, ùíú ≥]
        @test get_areas(ùí∞) == ùíú ≥
        @test ùíú ≥ ‚â† ùíú
        @test ùí© ≥ ‚â† ùí©

        # Test the individual resets of the areas
        @test availability_node(ùíú ≥[1]) == ùí© ≥[1]
        @test availability_node(ùíú ≥[2]) == ùí© ≥[1]
        @test exchange_limit(ùíú ≥[2], H2_hp).vals == prof_1[opers_opt]
        @test exchange_limit(ùíú ≥[2], el).vals == prof_2[opers_opt]
    end
end


@testset "Identification - TransmissionMode" begin
    # Create the individual resources
    H2_hp = ResourceCarrier("H2_hp", 0.0)
    H2_lp = ResourceCarrier("H2_lp", 0.0)
    el = ResourceCarrier("Power", 0.0)
    co2 = ResourceEmit("co2", 1.0)
    resources = [H2_hp, H2_lp, el, co2]

    # Create the profiles
    n_op = 15
    dur_op = ones(n_op)
    prof_1 = OperationalProfile(rand(n_op))
    prof_2 = OperationalProfile(rand(n_op))


    # Initialize the individual modes of the corridors
    static = RefStatic(
        "static",
        co2,
        prof_1,
        FixedProfile(0.01),
        FixedProfile(0.1),
        FixedProfile(1),
        2,
    )
    dynamic = RefDynamic(
        "dynamic",
        el,
        FixedProfile(30.0),
        prof_2,
        FixedProfile(0.1),
        FixedProfile(1),
        2,
    )
    pipe = PipeSimple(
        "pipe",
        H2_hp,
        H2_lp,
        el,
        prof_1,
        FixedProfile(20),
        FixedProfile(0.01),
        prof_2,
        FixedProfile(2.5),
    )

    # Create the Transmission corridors
    av = GeoAvailability(1, resources)
    ùí© = EMB.Node[av]
    a_1 = RefArea(2, "RefArea", 1, 1, av)
    a_2 = LimitedExchangeArea(1, "LEArea", 1, 1, av, Dict(H2_hp => prof_1, el => prof_2))
    ùíú = [a_1, a_2]
    l_stat_dyn = Transmission(a_1, a_2, [static, dynamic])
    l_pipe = Transmission(a_1, a_2, [pipe])
    ‚Ñí·µó ≥·µÉ‚ÅøÀ¢ = [l_stat_dyn, l_pipe]

    @testset "Path creation" begin
        # Test of all potential node input from EMRH as called through the function
        # - _find_update_paths(x::Union{AbstractElement, Resource, RecHorEnergyModel})

        # The individual function flow is included on top

        # Test of a transmission corridor with two modes
        # - _find_update_paths(field::AbstractElement, current_path::Vector{Any}, all_paths::Vector{Any})
        # - _find_update_paths(field::T, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}
        # - _find_update_paths(field::Vector{<:T}, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}
        # - _find_update_paths(field::OperationalProfile, current_path::Vector{Any}, all_paths::Vector{Any})
        @test issetequal(
            EMRH._find_update_paths(l_stat_dyn),
            [
                [:from, EMRH.ElementPath()],
                [:to, EMRH.ElementPath()],
                [:modes, "[1]", :trans_cap, EMRH.OperPath()],
                [:modes, "[2]", :trans_loss, EMRH.OperPath()],
            ],
        )

        # Test of a transmission corridor with a pipeline mode
        # - _find_update_paths(field::AbstractElement, current_path::Vector{Any}, all_paths::Vector{Any})
        # - _find_update_paths(field::T, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}
        # - _find_update_paths(field::Vector{<:T}, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}
        # - _find_update_paths(field::OperationalProfile, current_path::Vector{Any}, all_paths::Vector{Any})
        @test issetequal(
            EMRH._find_update_paths(l_pipe),
            [
                [:from, EMRH.ElementPath()],
                [:to, EMRH.ElementPath()],
                [:modes, "[1]", :consumption_rate, EMRH.OperPath()],
                [:modes, "[1]", :opex_var, EMRH.OperPath()],
            ],
        )
    end

    @testset "Lens creation" begin
        # Create the lenses
        lens_dict = EMRH._create_lens_dict(‚Ñí·µó ≥·µÉ‚ÅøÀ¢)

        # Test that the lenses are created for all transmission corridors
        # - _create_lens_dict(ùí≥::Vector{<:AbstractElement}
        # - _create_lens_dict(x::Union{AbstractElement, RecHorEnergyModel})
        # - _create_lens_for_field(field_id::Vector{<:Any})
        @test all(haskey(lens_dict, l) for l ‚àà ‚Ñí·µó ≥·µÉ‚ÅøÀ¢)

        # Test that the individual lenses are correctly created and working
        l = l_stat_dyn
        @test lens_dict[l][[:from, EMRH.ElementPath()]](l) == a_1
        @test lens_dict[l][[:to, EMRH.ElementPath()]](l) == a_2
        @test lens_dict[l][[:modes, "[1]", :trans_cap, EMRH.OperPath()]](l) == prof_1
        @test lens_dict[l][[:modes, "[2]", :trans_loss, EMRH.OperPath()]](l) == prof_2

        l = l_pipe
        @test lens_dict[l][[:from, EMRH.ElementPath()]](l) == a_1
        @test lens_dict[l][[:to, EMRH.ElementPath()]](l) == a_2
        @test lens_dict[l][[:modes, "[1]", :consumption_rate, EMRH.OperPath()]](l) == prof_1
        @test lens_dict[l][[:modes, "[1]", :opex_var, EMRH.OperPath()]](l) == prof_2
    end

    @testset "Reset functionality" begin
        # Create an operational modeltype and the time structure
        modeltype = RecHorOperationalModel(
            Dict(co2 => FixedProfile(100)),
            Dict(co2 => FixedProfile(60)),
            co2,
        )

        # Create the update type
        ùí∞ = EMRH._create_updatetype(modeltype)
        EMRH._add_elements!(ùí∞, ùí©)
        EMRH._add_elements!(ùí∞, ùíú)
        EMRH._add_elements!(ùí∞, ‚Ñí·µó ≥·µÉ‚ÅøÀ¢)

        # Create all time related parameters
        ùíØ = TwoLevel(1, 1, SimpleTimes(dur_op))
        opers = collect(ùíØ)
        ‚Ñã = PeriodHorizons(dur_op, 4, 2)
        ùíΩ = first(‚Ñã)
        ùíØ·µ£‚Çï = TwoLevel(1, sum(durations(ùíΩ)), SimpleTimes(durations(ùíΩ)))
        ind_impl = indices_implementation(ùíΩ)
        opers_opt = opers[indices_optimization(ùíΩ)]
        opers_impl = opers[ind_impl]
        opers_impl·µ£‚Çï = collect(ùíØ·µ£‚Çï)[1:length(ind_impl)]

        # Test that the individual reset types functions are working
        # All functions are located within the file src/structures/reset.jl
        ùíÆ·µõ·µâ·∂ú = EMRH.get_sub_elements_vec(ùí∞)
        @test isa(ùíÆ·µõ·µâ·∂ú[3], Vector{EMGExt.TransmissionSub})
        @test EMRH.get_sub_ele(ùí∞, Transmission) == ùí∞.elements[3]
        @test EMRH.get_sub_ele(ùíÆ·µõ·µâ·∂ú, Transmission) == ùí∞.elements[3]

        # Test the resets (ElementReset)
        reset_trans = EMRH.resets(ùíÆ·µõ·µâ·∂ú[3][1])
        l = l_stat_dyn
        @test all(isa(reset_trans[k], EMRH.ElementReset) for k ‚àà [1,2])
        @test reset_trans[1].lens(l) == a_1
        @test reset_trans[1].val == a_1
        @test reset_trans[2].lens(l) == a_2
        @test reset_trans[2].val == a_2

        # Test that the reset are working
        # - _update_update_case!(ùí∞, opers_opt, ùíØ·µ£‚Çï)
        # - _update_case_types!
        # - reset_field
        EMRH._update_update_case!(ùí∞, opers_opt, ùíØ·µ£‚Çï)

        # Extract the resetted nodes, areas, and transmission corridors
        ùí© ≥ = [s.new for s ‚àà ùíÆ·µõ·µâ·∂ú[1]]
        ùíú ≥ = [s.new for s ‚àà ùíÆ·µõ·µâ·∂ú[2]]
        ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥ = [s.new for s ‚àà ùíÆ·µõ·µâ·∂ú[3]]
        @test get_elements_vec(ùí∞) == Vector[ùí© ≥, ùíú ≥, ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥]
        @test get_transmissions(ùí∞) == ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥
        @test ùí© ≥ ‚â† ùí©
        @test ùíú ≥ ‚â† ùíú
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥ ‚â† ‚Ñí·µó ≥·µÉ‚ÅøÀ¢

        # Test the individual resets of the transmission corridor
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[1].from == ùíú ≥[1]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[1].to == ùíú ≥[2]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[1].modes[1].trans_cap.vals == prof_1[opers_opt]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[1].modes[2].trans_loss.vals == prof_2[opers_opt]

        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[2].from == ùíú ≥[1]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[2].to == ùíú ≥[2]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[2].modes[1].consumption_rate.vals == prof_1[opers_opt]
        @test ‚Ñí·µó ≥·µÉ‚ÅøÀ¢‚Åª ≥[2].modes[1].opex_var.vals == prof_2[opers_opt]
    end
end
