var documenterSearchIndex = {"docs":
[{"location":"how-to/adapt-emx-elem/#how_to-adapt_elem","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"","category":"section"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"This package is based on EnergyModelsBase, and therefore several aspects of creating a new element are covered in its documentation. In this page, we will focus on the specific requirements for the introduction of new AbstractElements in the receding horizon framework.","category":"page"},{"location":"how-to/adapt-emx-elem/#how_to-adapt_elem-init","page":"Adapt an EMX element","title":"Initialization settings","text":"","category":"section"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"An element that presents dynamic states (e.g., storage levels, ...) must have these states explicitly initialized. In this package, this is done by the introduction of an AbstractInitData object. AbstractInitData is an abstract type, and the concrete type InitData is provided with the minimum expected functionality for such an object. The AbstractInitData must be used in the model equations to calculate the initial states of the corresponding element.","category":"page"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"It is possible to initialize a node through dispatch on EMB.constraints_data. An example of such implementation is provided in the test files for the creation of a new node IncrementInitNode, see the file nodewithinitial_data.jl. However, care must be taken when defining the initial state as such, so as to not overspecify the system of equations.","category":"page"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"Some nodes have a more specialized way of initialization, such as Storage nodes. Here, we implement the RecedingAccumulating behavior, where the initial level state can be defined through an StorageInitData object. Initialization here is defined by dispatching on previous_level, which is already used in the core Storage functionality (see the EnergyModelsBase documentation).","category":"page"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"Additionally, one must create dispatches upon update_init_data! for new implementations of AbstractInitData, as well as on other functions, see page on problem initialization for the full list. This is not needed for elements that can use InitData and its default functionalities.","category":"page"},{"location":"how-to/adapt-emx-elem/#how_to-adapt_elem-inner_con","page":"Adapt an EMX element","title":"Elements with special constructors","text":"","category":"section"},{"location":"how-to/adapt-emx-elem/","page":"Adapt an EMX element","title":"Adapt an EMX element","text":"For elements with specific constructor needs, it is necessary to dispatch on Accessors.ConstructionBase.constructorof. This includes elements with parametric types for which the parametric input cannot be deduced from the fields (e.g., Storage nodes), as well as elements with inner constructors. An example of how this can be done is shown in the package for the Storage node (see the constructorof dispatch).","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J.¬†Mattingley, Y.¬†Wang and S.¬†Boyd. Receding horizon control. IEEE¬†Control¬†Systems¬†Magazine 31, 52‚Äì65 (2011).\n\n\n\nP.¬†Aaslid, M.¬†Korp√•s, M.¬†M.¬†Belsnes and O.¬†B.¬†Fosso. Pricing electricity in constrained networks dominated by stochastic renewable generation and electric energy storage. Electric¬†Power¬†Systems¬†Research 197, 107169 (2021).\n\n\n\nO.¬†Dowson. The policy graph decomposition of multistage stochastic programming problems. Networks 76, 3‚Äì23 (2020), arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/net.21932.\n\n\n\n","category":"page"},{"location":"library/internals/reset/#lib-int-reset","page":"Resetting functionality","title":"Resetting functionality","text":"","category":"section"},{"location":"library/internals/reset/#lib-int-reset-idx","page":"Resetting functionality","title":"Index","text":"","category":"section"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"Pages = [\"reset.md\"]","category":"page"},{"location":"library/internals/reset/#lib-int-reset-path","page":"Resetting functionality","title":"Paths","text":"","category":"section"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"Path are internal types that are used for the identification of a reset. They are used internally for dispatch.","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.AbstractPath\nEMRH.OperPath\nEMRH.ElementPath\nEMRH.TimeWeightPath\nEMRH.AbstractInitDataPath\nEMRH.InitDataPath","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.AbstractPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.AbstractPath","text":"abstract type AbstractPath\n\nSupertype for identification of the type which is resetted by a lens.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.OperPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.OperPath","text":"struct OperPath <: AbstractPath\n\nInternal type for paths pointing towards operational profiles.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.ElementPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.ElementPath","text":"struct ElementPath <: AbstractPath\n\nInternal type for paths pointing towards elements.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.TimeWeightPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.TimeWeightPath","text":"struct TimeWeightPath <: AbstractPath\n\nInternal type for paths pointing towards the time weight of a future value.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.AbstractInitDataPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.AbstractInitDataPath","text":"abstract type AbstractInitDataPath <: AbstractPath\n\nSupertype for identification of the AbstractPath types that are used for initial data. If you create a new AbstractInitData type, you must also create a new AbstractInitDataPath subtype\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.InitDataPath","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.InitDataPath","text":"struct InitDataPath <: AbstractInitDataPath\n\nInternal type for paths pointing towards InitData.\n\nFields\n\nkey::Symbol is the key in the InitData (and correspondingly in the JuMP model).\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"The following function is included for extracting the values from paths:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.model_key(idp::EMRH.InitDataPath)","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.model_key-Tuple{EnergyModelsRecedingHorizon.InitDataPath}","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.model_key","text":"model_key(idp::InitDataPath)\n\nReturns the model key (field key) of InitDataPath idp.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"note: Resetting new values\nIf you must reset a different type of value than outlined below, you must also create a new type. This is especially important when creating a new AbstractInitData.","category":"page"},{"location":"library/internals/reset/#lib-int-reset-reset","page":"Resetting functionality","title":"Reset types","text":"","category":"section"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"Reset types are introduced to differentiate on what must be reset in a given element. They are used internally for dispatch.","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.AbstractReset\nEMRH.ElementReset\nEMRH.OperReset\nEMRH.TimeWeightReset\nEMRH.InitReset\nEMRH.ResetType","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.AbstractReset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.AbstractReset","text":"abstract type AbstractReset\n\nSupertype for types resetting values in fields in the individual AbstractElements. The individual subtype is related to the chosen AbstractPath as outlined above.\n\nnote: New subtypes\nWe currently have reset types for elements (e.g., nodes, links, areas, or transmission), operational profiles, and initial data. The individual types are automatically deduced through the constructor ResetType.If you require resetting different fields than the provided, you must include a new AbstractPath subtype, a new mutable composite type as subtype of AbstractReset, and a new method for the the constructor ResetType.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.ElementReset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.ElementReset","text":"mutable struct ElementReset <: AbstractReset\n\nAbstractReset for resetting elements within another. The inner constructor is utilized for automatically creating the lens to the field path.\n\nInner constructor arguments\n\nfield_path::Vector is the path towards the field as identified through the function _find_update_paths.\nx is the instance of a type for which the reset type is created.\n\nFields\n\nlens::Union{PropertyLens,ComposedFunction} is the lens for resetting the field.\nval::AbstractElement is the element in the field of the original instance. It is used for identifying the linked AbstractElement after it is reset.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.OperReset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.OperReset","text":"mutable struct OperReset <: AbstractReset\n\nAbstractReset for resetting operational profiles within an element. The inner constructor is utilized for automatically creating the lens to the field path.\n\nInner constructor arguments\n\nfield_path::Vector is the path towards the field as identified through the function _find_update_paths.\nx is the instance of a type for which the reset type is created.\n\nFields\n\nlens::Union{PropertyLens,ComposedFunction} is the lens for resetting the field.\nvar is the variable when using ParametricOptInterface.\nval::OperationalProfile is the complete operational profile from the original element. The individual values are extracted from this profile in the receding horizon framework.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.TimeWeightReset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.TimeWeightReset","text":"mutable struct TimeWeightReset <: AbstractReset\n\nAbstractReset for resetting the time weight used in future value calculations.\n\nInner constructor arguments\n\nfield_path::Vector is the path towards the field as identified through the function _find_update_paths.\nx is the instance of a type for which the reset type is created.\n\nFields\n\nlens::Union{PropertyLens,ComposedFunction} is the lens for resetting the field.\nvar is the variable when using ParametricOptInterface.\nval is the time weight that should be used in the analysis.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.InitReset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.InitReset","text":"mutable struct InitReset{T} <: AbstractReset where {T<:AbstractInitDataPath}\n\nAbstractReset for resetting initial data of an element. The inner constructor is utilized for automatically creating the lens to the field path.\n\nInner constructor arguments\n\nfield_path::Vector is the path towards the field as identified through the function _find_update_paths.\npath::AbstractInitDataPath is the AbstractPath of the init data. It includes additional information that is utilized when resetting an element.\nx is the instance of a type for which the reset type is created.\n\nFields\n\nlens::Union{PropertyLens,ComposedFunction} is the lens for resetting the field.\npath::AbstractInitDataPath is the AbstractPath of the init data. It includes additional information that is utilized when resetting an element.\nvar is the variable when using ParametricOptInterface.\nval is the initial data value that should be used in the analysis.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.ResetType","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.ResetType","text":"ResetType(field_path::Vector, _::OperPath, x)\nResetType(field_path::Vector, _::ElementPath, x)\nResetType(field_path::Vector, _::TimeWeightPath, x)\nResetType(field_path::Vector, path::AbstractInitDataPath, x)\n\nConstructor for AbstractReset types depending on their specified AbstractPath.\n\nnote: New types\nIf you create a new AbstractReset type (due to the creation of a new [AbstractPath] type), you must also create a new method for this function.This is not necessary for a new subtype of AbstractInitDataPath.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"The following function is included for identification purposes:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.is_init_reset","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.is_init_reset","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.is_init_reset","text":"is_init_reset(rt::AbstractReset)\n\nFunction fo identifying whether the AbstractReset rt is of type InitReset.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"note: Resetting new values\nIf you must reset a different type of value than outlined below, you must also create a new type. If you create a new AbstractPath, it is not neccesary to create a new type.In this case, you must also create a new method for ResetType as this function is used internally.","category":"page"},{"location":"library/internals/reset/#lib-int-reset-sub","page":"Resetting functionality","title":"Substitution types","text":"","category":"section"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"Substitution types correspond to types that store information of the individual original instance, the updated instance, and all required resets of an object:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.AbstractSub\nEMRH.ModelSub\nEMRH.ProductSub\nEMRH.NodeSub\nEMRH.LinkSub\nEMRH.FutureValueSub\nEMRH.Substitution","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.AbstractSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.AbstractSub","text":"abstract type AbstractSub\n\nSupertype for the creation of Substitution types.\n\nSubstitution types are used for simpler identification of the structures for substitutions.\n\nnote: New elements\nIf you include a new element, you must introduce a new AbstractSub type for the element.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.ModelSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.ModelSub","text":"mutable struct ModelSub{T<:RecHorEnergyModel} <: AbstractSub\n\nAbstractSub for RecHorEnergyModel.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given RecHorEnergyModel.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.ProductSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.ProductSub","text":"mutable struct ProductSub{T<:Resource} <: AbstractSub\n\nAbstractSub for Resources.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given Resource.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.NodeSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.NodeSub","text":"mutable struct NodeSub{T<:EMB.Node} <: AbstractSub\n\nAbstractSub for Nodes.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given Node.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.LinkSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.LinkSub","text":"mutable struct LinkSub{T<:Link} <: AbstractSub\n\nAbstractSub for Links.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given Link.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.FutureValueSub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.FutureValueSub","text":"mutable struct FutureValueSub{T<:FutureValue} <: AbstractSub\n\nAbstractSub for FutureValues.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given FutureValue.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.Substitution","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.Substitution","text":"Substitution(x::T, resets::Vector{<:AbstractReset}) where {T}\nSubstitution(new::T, org::T, resets::Vector{<:AbstractReset}) where {T<:Resource}\nSubstitution(new::T, org::T, resets::Vector{<:AbstractReset}) where {T<:RecHorEnergyModel}\nSubstitution(new::T, org::T, resets::Vector{<:AbstractReset}) where {T<:AbstractElement}\n\nConstructor for AbstractSub types depending on the specified type of the input.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"The following function is included for extracting the values from substitution types:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.resets","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.resets","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.resets","text":"resets(s::AbstractSub)\n\nReturns the Vector{AbstractReset} of the AbstractSub s.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"The following function is included for simplifying the overall code structure:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH._ele_to_sub","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon._ele_to_sub","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon._ele_to_sub","text":"_ele_to_sub(::Type{<:EMB.Node})\n_ele_to_sub(::Type{<:Link})\n_ele_to_sub(::Type{<:FutureValue})\n\nReturns the subtype of AbstractSub for a given element.\n\nnote: New elements\nIf you include a new element, you must introduce a new method for this function.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"note: Introducing new Elements\nIf you introduce new AbstractElements, you must also create a new subtype of AbstractSub, similar to NodeSub or LinkSub. The new subtype should have the same fields as the other subtypes.In this case, you must also create a new method for _ele_to_sub","category":"page"},{"location":"library/internals/reset/#lib-int-reset-update","page":"Resetting functionality","title":"Update case type","text":"","category":"section"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"All update information for updating/resetting the case dictionary and the model is stored within a single type:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.UpdateCase","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.UpdateCase","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.UpdateCase","text":"mutable struct UpdateCase <: AbstractCase\n\nType including all information required for updating the individual fields of the elements in a receding horizon model.\n\nThis type follows in general the same structure as the Case type introduced in EnergyModelsBase in which the individual vectors of Resources or AbstractElements are replaced with the corresponding vectors of AbstractSub.\n\nFields\n\nmodel::ModelSub is the substitution type for the RecHorEnergyModel.\nopers::Dict is a dictionary for mapping the operational periods of the receding horizon problem to the operational periods of the full problem.\nproducts::Vector{<:ProductSub} is a vector of substitution types for the individual Resources.\nelements::elements::Vector{Vector} is a vector of vectors of substitution types for the individual AbstractElements.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"The following functions are included for extracting the values from paths:","category":"page"},{"location":"library/internals/reset/","page":"Resetting functionality","title":"Resetting functionality","text":"EMRH.get_sub_model\nEMRH.get_sub_periods\nEMRH.get_sub_products\nEMRH.get_sub_elements_vec\nEMRH.get_sub_ele\nEMRH.updated\nEMRH.original","category":"page"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.get_sub_model","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.get_sub_model","text":"get_sub_model(ùí∞::UpdateCase)\n\nReturns the ModelSub type of UpdateCase ùí∞.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.get_sub_periods","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.get_sub_periods","text":"get_sub_periods(ùí∞::UpdateCase)\n\nReturns the periods mapping dictionary of UpdateCase ùí∞.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.get_sub_products","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.get_sub_products","text":"get_sub_products(ùí∞::UpdateCase)\n\nReturns the products Vector of UpdateCase ùí∞.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.get_sub_elements_vec","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.get_sub_elements_vec","text":"get_sub_elements_vec(ùí∞::UpdateCase)\n\nReturns the elements Vector{Vector} of UpdateCase ùí∞.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.get_sub_ele","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.get_sub_ele","text":"get_sub_ele(ùíÆ·µõ·µâ·∂ú::Vector{Vector}, x::Type{<:AbstractElement})\nget_sub_ele(ùí∞::UpdateCase, x::Type{<:AbstractElement})\n\nReturns the Vector of AbstractSub corresponding to the type provided by x.\n\nThe function can be used both on an UpdateCase and the corresponding Vector{Vector}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.updated","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.updated","text":"updated(ùí∞::UpdateCase, x_org::AbstractElement)\nupdated(ùí∞::UpdateCase, x_org::Resource)\nupdated(ùíÆ::Vector{<:AbstractSub}, x_org::AbstractElement)\nupdated(s::AbstractSub)\n\nReturns the updated (resetted) instance of the original instance x_org for a given UpdateCase. It is used for mapping and replacing instances of the type in fields.\n\nIf the input is an AbstractSub, it returns the value of the field new.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reset/#EnergyModelsRecedingHorizon.original","page":"Resetting functionality","title":"EnergyModelsRecedingHorizon.original","text":"original(ùí∞::UpdateCase, x_new::AbstractElement)\noriginal(ùí∞::UpdateCase, x_new::Resource)\noriginal(ùí∞::UpdateCase, x_new::TS.TimePeriod)\noriginal(ùíÆ::Vector{<:AbstractSub}, x_new::AbstractElement)\noriginal(s::AbstractSub)\n\nReturns the original instance of the new (resetted) instance x_new for a given UpdateCase. It is used for results extraction.\n\nIf the input is an AbstractSub, it returns the value of the field org.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/types-EMRH/#lib-int-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/internals/types-EMRH/#lib-int-types-idx","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/internals/types-EMRH/","page":"Types","title":"Types","text":"Pages = [\"types-EMRH.md\"]","category":"page"},{"location":"library/internals/types-EMRH/#lib-int-types-typ","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/internals/types-EMRH/","page":"Types","title":"Types","text":"EMRH.EnergyModelsRecedingHorizon","category":"page"},{"location":"library/internals/types-EMRH/#EnergyModelsRecedingHorizon.EnergyModelsRecedingHorizon","page":"Types","title":"EnergyModelsRecedingHorizon.EnergyModelsRecedingHorizon","text":"Main module for EnergyModelsRecedingHorizon, a package that extends EnergyModelsX with the implementation of a receding horizon framework for stress testing the invested energy system in an operational framework.\n\n\n\n\n\n","category":"module"},{"location":"library/internals/types-EMRH/#lib-int-types-typ-mod","page":"Types","title":"Model","text":"","category":"section"},{"location":"library/internals/types-EMRH/","page":"Types","title":"Types","text":"EMRH.RecHorEnergyModel","category":"page"},{"location":"library/internals/types-EMRH/#EnergyModelsRecedingHorizon.RecHorEnergyModel","page":"Types","title":"EnergyModelsRecedingHorizon.RecHorEnergyModel","text":"abstract type RecHorEnergyModel <: EnergyModel end\n\nAbstract type for receding horizon models.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMRH/#lib-int-types-typ-mod-2","page":"Types","title":"Horizons","text":"","category":"section"},{"location":"library/internals/types-EMRH/","page":"Types","title":"Types","text":"EMRH.AbstractHorizons\nEMRH.SingleHorizon","category":"page"},{"location":"library/internals/types-EMRH/#EnergyModelsRecedingHorizon.AbstractHorizons","page":"Types","title":"EnergyModelsRecedingHorizon.AbstractHorizons","text":"AbstractHorizons{T<:Real}\n\nAbstract supertype for the individual composite types that can be used for passing the required parameters for a receding horizon optimization.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMRH/#EnergyModelsRecedingHorizon.SingleHorizon","page":"Types","title":"EnergyModelsRecedingHorizon.SingleHorizon","text":"SingleHorizon{T}\n\nType created as a result of iterating through an AbstractHorizons type. It stores the required information of each individual optimization.\n\nFields\n\nid::Int64 is an integer corresponding to the number of the type from the iterator.\ndur::Vector{T} is a vector of the duration of the operational period included in the horizon.\nidx_optim::Vector{Int64} is a vector containing the indices used in the optimization horizon.\nidx_impl::Vector{Int64} is a vector containing the indices used in the implementation horizon.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/methods-EMRH/#lib-int-met","page":"Methods - Internal","title":"Methods - Internal","text":"","category":"section"},{"location":"library/internals/methods-EMRH/#lib-int-met-idx","page":"Methods - Internal","title":"Index","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"Pages = [\"methods-EMRH.md\"]","category":"page"},{"location":"library/internals/methods-EMRH/#lib-int-ext","page":"Methods - Internal","title":"Extension functions","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.update_init_data!","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.update_init_data!","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.update_init_data!","text":"update_init_data!(m, ri::AbstractReset, x::AbstractElement, idp::InitDataPath, opers_impl·µ£‚Çï)\n\nUpdates the values of AbstractElement x for the AbstractReset ri with the value specified by the key of the idp.\n\n\n\n\n\nEMRH.update_init_data!(m, ri::AbstractReset, l::Transmission, idp::TransInitDataPath, opers_impl·µ£‚Çï)\n\nUpdates the initial values of Transmission  corridor l for the AbstractReset ri with the value specified by the key of the TransInitDataPath idp.\n\nThe mode for the variable is identified through the field idx of TransInitDataPath.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#lib-int-util","page":"Methods - Internal","title":"Utility functions","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.update_results!\nEMRH.save_results\nEMRH.get_results\nEMRH.get_results_df","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.update_results!","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.update_results!","text":"update_results!(results, m, ùí∞, opers, ùíΩ)\n\nUpdates results given the optimization results m for the times opers, performed in horizon ùíΩ. The results are indexed by the elements in the provided case (here accessed using the UpdateCase ùí∞).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.save_results","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.save_results","text":"save_results(model::Model; directory=joinpath(pwd(),\"csv_files\"))\nsave_results(results::Dict{Symbol, AbstractDataFrame}; directory=joinpath(pwd(),\"csv_files\"))\n\nSaves the model results of all variables as CSV files. The model results are saved in the specified directory. If no directory is specified, it will create, if necessary, a new directory \"csv_files\" in the current working directory and save the files in said directory.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.get_results","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.get_results","text":"get_results(m::JuMP.Model)\n\nFunction returning the values of the optimized model m. Prints a warning message for currently unsupported types without extracting their value.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.get_results_df","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.get_results_df","text":"get_results_df(m::JuMP.Model)\n\nFunction returning the values of the optimized model m as a DataFrame. Prints a warning message for currently unsupported types without extracting their value.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#lib-int-ext-2","page":"Methods - Internal","title":"Miscellaneous functions","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.init_level\nEMRH._create_lens_dict","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.init_level","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.init_level","text":"init_level(n::Storage{RecedingAccumulating})\n\nGets initialization values for the Storage node n from its data fields.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._create_lens_dict","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._create_lens_dict","text":"_create_lens_dict(ùí≥::Vector{<:AbstractElement}\n_create_lens_dict(x::Union{AbstractElement, RecHorEnergyModel})\n\nReturns a dictionary with the field id as keys and lenses pointing to fields that are updated in the individual type instances as values. The individual field ids are created through calling the function _find_update_paths, and the lenses are created with _create_lens_for_field.\n\nLenses are created for\n\nall OperationalProfiles,\nother AbstractElement, and\nInitData.\n\nExample\n\nusing EnergyModelsBase\nusing EnergyModelsRecedingHorizon\nusing TimeStruct\nconst EMRH = EnergyModelsRecedingHorizon\n\n# Generate objects\ncap_prof = OperationalProfile([20, 300])\nem_prof = OperationalProfile([1, 2])\nprice_prof = OperationalProfile([40, 60])\n\npower = ResourceCarrier(\"power\", 0.0)\nco2 = ResourceEmit(\"co2\", 1.0)\n\nsource1 = RefSource(\n    \"source1\",\n    cap_prof,\n    FixedProfile(100),\n    FixedProfile(0),\n    Dict(power => 1),\n    [EmissionsProcess(Dict(co2 => em_prof))]\n)\nsource2 = RefSource(\n    \"source2\",\n    FixedProfile(100),\n    price_prof,\n    FixedProfile(0),\n    Dict(power => 1),\n)\n\n# Create a dictionary containing lenses to the OperationalProfile\nd_all = EMRH._create_lens_dict([source1, source2])\n# Returns Dict{RefSource, Dict{Vector{Any}}} with 2 entries:\n n_source1 => Dict{Vector{Any}, Any}([:data, \"[1]\", :emissions, co2, OperPath()]=>_.data[1].emissions[co2], [:cap, OperPath()]=>_.cap)\n n_source2 => Dict{Vector{Any}, PropertyLens{:opex_var}}([:opex_var, OperPath()]=>_.opex_var)\n\nd_s1 = EMRH._create_lens_dict(source1)\n# Returns Dict{Vector{Any}, Any} with 2 entries:\n [:data, \"[1]\", :emissions, co2, OperPath()] => _.data[1].emissions[co2]\n [:cap, OperPath()]                          => _.cap\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#lib-int-ident","page":"Methods - Internal","title":"Identification functions","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH._find_update_paths(x::T) where {T <: Union{AbstractElement, Resource, EMRH.RecHorEnergyModel}}\nEMRH._dict_key\nEMRH._create_lens_for_field\nEMRH._path_type","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._find_update_paths-Tuple{T} where T<:Union{AbstractElement, Resource, EnergyModelsRecedingHorizon.RecHorEnergyModel}","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._find_update_paths","text":"_find_update_paths(x::Union{AbstractElement, Resource, RecHorEnergyModel})\n_find_update_paths(x::StorageValueCuts)\n\nReturns all paths within an AbstractElement, a Resource, a RecHorEnergyModel, or a StorageValueCuts that must be updated in the receding horizon framework as Vector{Vector}.\n\nThe individual subfunctions are given as:\n\n_find_update_paths(field::AbstractElement, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::StorageValueCut, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::Vector{<:Data}, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::T, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:Union{Data, EMB.AbstractStorageParameters, ElementValue}}\n_find_update_paths(field::AbstractDict, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::OperationalProfile, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::StrategicProfile, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::Any, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::AbstractInitData, current_path::Vector{Any}, all_paths::Vector{Any})\n_find_update_paths(field::InitData, current_path::Vector{Any}, all_paths::Vector{Any})\n\nnote: Introducing new `AbstractInitData`\nWhen introducing a new subtype to AbstractInitData, you must also create a new method for this function as it is not possible to cover all potential cases in which the new data is designed.\n\nExample\n\npower = ResourceCarrier(\"power\", 0.0)\nco2 = ResourceEmit(\"co2\", 1.0)\nsink = RefSink(\n    \"a_sink\",                                               # Field `:id`\n    FixedProfile(1e5),                                      # Field `:cap`\n    Dict(:surplus => OperationalProfile(zeros(10)),\n         :deficit => OperationalProfile(10*ones(10))),      # Field `:penalty`\n    Dict(power => 1),                                       # Field `:input`\n    [EmissionsProcess(Dict(co2 => OperationalProfile(rand(10))))] # Field `:data`\n)\n\nEMRH._find_update_paths(sink)\n# returns a 3-element Vector{Any}:\n Any[:penalty, \"[:deficit]\", EnergyModelsRecedingHorizon.OperPath()]\n Any[:penalty, \"[:surplus]\", EnergyModelsRecedingHorizon.OperPath()]\n Any[:data, \"[1]\", :emissions, co2, EnergyModelsRecedingHorizon.OperPath()]\n\n# The function can also be used for checking other `types`:\nall_paths = []\ncurrent_path = Any[:a_path]\na_dict = Dict(:a => Dict(:b1 => Dict(:c => OperationalProfile([1])),\n    :b2 => OperationalProfile([1]), :b3 => [1]))\n\nEMRH._find_update_paths(a_dict, current_path, all_paths)\n# all_paths is now a 2-element Vector{Any}:\n Any[:a_path, \"[:a]\", \"[:b2]\", EnergyModelsRecedingHorizon.OperPath()]\n Any[:a_path, \"[:a]\", \"[:b1]\", \"[:c]\", EnergyModelsRecedingHorizon.OperPath()]\n\n\n\n\n\n","category":"method"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._dict_key","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._dict_key","text":"_dict_key(key::Symbol)\n_dict_key(key::String)\n_dict_key(key::Resource)\n\nFunction for translating a dictionary key type to an input which can be parsed into a lens.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._create_lens_for_field","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._create_lens_for_field","text":"_create_lens_for_field(field_id::Vector{<:Any})\n\nReturns a lens, which can be used to inspect or reset variables. The lens is based on the field_id obtained through the function _find_update_paths.\n\nExample:\n\nusing Accessors: @reset\nusing EnergyModelsBase\nusing EnergyModelsRecedingHorizon\nusing TimeStruct\nconst EMRH = EnergyModelsRecedingHorizon\n\ncap_prof = OperationalProfile([20, 300])\nem_prof = OperationalProfile([1,2])\npower = ResourceCarrier(\"power\", 0.0)\nco2 = ResourceEmit(\"co2\", 1.0)\n\nsource = RefSource(\n    \"power_source\",                         # Node id or name\n    cap_prof,                               # Capacity\n    FixedProfile(100),                      # Variable OPEX\n    FixedProfile(0),                        # Fixed OPEX\n    Dict(power => 1),                       # Output from the node\n    [EmissionsProcess(Dict(co2 => em_prof))] # Line above: CO2 process emissions\n)\n\npaths_oper_source = EMRH._find_update_paths(source)\n@assert all(paths_oper_source .== Any[\n    [:cap, EMRH.OperPath()], [:data, \"[1]\", :emissions, co2, EMRH.OperPath()]\n])\nlens_source_cap = EMRH._create_lens_for_field(paths_oper_source[1])\nlens_source_data = EMRH._create_lens_for_field(paths_oper_source[2])\n\n# Check that the values returned through the lenses are based on the actual values\n@assert all(cap_prof == lens_source_cap(source))\n@assert all(em_prof == lens_source_data(source))\n\n# Lenses can also be used for resetting values using @reset\ncap_prof_new = OperationalProfile([90,100])\n@reset lens_source_cap(source) = cap_prof_new\n@assert all(cap_prof_new == lens_source_cap(source))\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._path_type","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._path_type","text":"_path_type(val::Symbol)\n_path_type(val::String)\n_path_type(val::Resource)\n_path_type(val::AbstractPath)\n\nTranslate the individual value to the required format for creating the lense string.\n\nIn the case of a resource, it creates a global variable calles res which can be evaluated in the parse.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#lib-int-reset","page":"Methods - Internal","title":"Functions for resetting values","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH._create_updatetype\nEMRH._add_elements!\nEMRH._update_future_value!\nEMRH._update_update_case!\nEMRH._reset_field(x_rh, res_type::EMRH.ElementReset, ùí∞::EMRH.UpdateCase, opers::Vector{<:TS.TimePeriod})","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._create_updatetype","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._create_updatetype","text":"_create_updatetype(model::RecHorEnergyModel)\n\nInitialize an UpdateCase based on the provided RecHorEnergyModel model.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._add_elements!","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._add_elements!","text":"_add_elements!(ùí∞::UpdateCase, ùí´::Vector{T}) where {T<:Resource}\n_add_elements!(ùí∞::UpdateCase, ùí≥::Vector{T}) where {T<:AbstractElement}\n\nAdd the vector of Resources or AbstractElement substitution types to the UpdateCase ùí∞ for a given Vector{<:Resource} or Vector{<:AbstractElement}.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._update_future_value!","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._update_future_value!","text":"_update_future_value!(ùíÆ·µõ::Vector{FutureValueSub{T}}, time_elapsed::Real) where {T<:StorageValueCuts}\n\nUpdate the value of TimeWeightReset based on the time time_elapsed at the end of the TimeStructure.\n\nIf a cut is given at the end time of an operational period, the weight is 1 for the given cut and 0 for other. When the optimization end time is between cuts, the weights scales the weight of the nearest cuts such that they are weighted linearly.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._update_update_case!","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._update_update_case!","text":"_update_update_case!(ùí∞, opers, ùíØ·µ£‚Çï)\n\nUpdate the UpdateCase ùí∞ with the new values in the optimization problem given by the time structure ùíØ·µ£‚Çï.\n\nIn addition, the UpdateCase ùí∞ is updated with the new mapping between the operational periods of the optimization (through ùíØ·µ£‚Çï) and the original (through opers) problem.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon._reset_field-Tuple{Any, EnergyModelsRecedingHorizon.ElementReset, EnergyModelsRecedingHorizon.UpdateCase, Vector{<:TimeStruct.TimePeriod}}","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon._reset_field","text":"_reset_field(x_rh, res_type::ElementReset, ùí∞::UpdateCase, opers::Vector{<:TS.TimePeriod})\n_reset_field(x_rh, res_type::Union{InitReset, TimeWeightReset}, ùí∞::UpdateCase, opers::Vector{<:TS.TimePeriod})\n_reset_field(x_rh, res_type::OperReset, ùí∞::UpdateCase, opers::Vector{<:TS.TimePeriod})\n\nResets the field expressed through res_type of element x_rh with the new value. The type of the new value is depending on the specified res_type:\n\nres_type::ElementReset uses ùí∞ for identifying the new element,\nres_type::Union{InitReset, TimeWeightReset} uses the value in res_type directly,\nres_type::OperReset creates a new operational profile based on the original operational profile in res_type and the set of operational periods opers.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"The following function is introduced for parametric types in which the type is not deducible from the input and for types with inner constructors:","category":"page"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.Accessors.ConstructionBase.constructorof","category":"page"},{"location":"library/internals/methods-EMRH/#ConstructionBase.constructorof","page":"Methods - Internal","title":"ConstructionBase.constructorof","text":"Accessors.ConstructionBase.constructorof(obj::Type{<:Storage})\n\nAllows using @reset for an obj <: Storage, which is declared as parametric type without the possibility to deduce the possibility to deduce the type parameter from the provided input.\n\nnote: Note\nDispatch on this function for functions using inner constructors, in order for @reset to work.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#lib-int-fut_val","page":"Methods - Internal","title":"Future value functions","text":"","category":"section"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.get_future_value_expression\nEMRH.create_future_value\nEMRH.create_future_value_couple","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.get_future_value_expression","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.get_future_value_expression","text":"get_future_value_expression(m, ùí±::Vector{StorageValueCuts}, ùíØ·¥µ‚Åø·µõ::TS.AbstractStratPers, modeltype::EnergyModel)\n\nReturns an expression equal to the weighted sum of the future_value of all active cuts. Inactive cuts are weighted with 0 but still included to keep the number of variables unchanged.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.create_future_value","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.create_future_value","text":"create_future_value(m, v::FutureValue, ùíØ, modeltype)\n\nSet all constraints for an FutureValue. Fallback option for all unspecified subtypes of FutureValue.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.create_future_value_couple","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.create_future_value_couple","text":"create_future_value_couple(m, v::StorageValueCuts, ùíØ, modeltype::EnergyModel)\n\nBuild cut constraints for all cuts in a StorageValueCuts element.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"The following functions for accessing fields of the types are introduced:","category":"page"},{"location":"library/internals/methods-EMRH/","page":"Methods - Internal","title":"Methods - Internal","text":"EMRH.coefficients\nEMRH.cut_rhs\nEMRH.weight\nEMRH.time_weight\nEMRH.cuts_time\nEMRH.cuts","category":"page"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.coefficients","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.coefficients","text":"coefficients(svc::StorageValueCut)\n\nReturns the cut coefficients associated with the level of the given Storage nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.cut_rhs","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.cut_rhs","text":"cut_rhs(svc::StorageValueCut)\n\nReturns the cut right hand side constant.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.weight","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.weight","text":"weight(svcs::StorageValueCuts)\n\nReturns the weight of the storage value cuts svcs.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.time_weight","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.time_weight","text":"time_weight(svcs::StorageValueCuts)\n\nReturns the time weight of the storage value cuts svcs.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.cuts_time","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.cuts_time","text":"cuts_time(svcs::StorageValueCuts)\n\nReturns the time at which the storage value cuts svcs are valid relative to the total horizon.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMRH/#EnergyModelsRecedingHorizon.cuts","page":"Methods - Internal","title":"EnergyModelsRecedingHorizon.cuts","text":"cuts(svcs::StorageValueCuts)\n\nReturns the different cuts of StorageValueCuts svcs.\n\n\n\n\n\n","category":"function"},{"location":"manual/simple-example/#man-ex","page":"Example","title":"Example","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"For the content of the individual examples, see the examples directory in the project repository.","category":"page"},{"location":"manual/simple-example/#The-package-is-installed-with-]-add","page":"Example","title":"The package is installed with ]¬†add","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"From the Julia REPL, run","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"# Starts the Julia REPL\njulia> using EnergyModelsRecedingHorizon\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsRecedingHorizon), \"examples\")\n# Include the code into the Julia REPL to run the examples\njulia> include(joinpath(exdir, \"base_example.jl\"))","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The other examples can be run using","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"julia> include(joinpath(exdir, \"geography.jl\"))\njulia> include(joinpath(exdir, \"storage_end_value.jl\"))","category":"page"},{"location":"manual/simple-example/#The-code-was-downloaded-with-git-clone","page":"Example","title":"The code was downloaded with git clone","text":"","category":"section"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"The examples can be run from the terminal with","category":"page"},{"location":"manual/simple-example/","page":"Example","title":"Example","text":"/path/to/EnergyModelsRecedingHorizon.jl/examples $ julia base_example.jl","category":"page"},{"location":"how-to/use-emrh/#how_to-use_emrh","page":"Use the package","title":"Use the package","text":"","category":"section"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"The main function of the EnergyModelsRecedingHorizon package is run_model_rh. Similarly to EnergyModelsBase, a problem is defined by its case and model objects. The following points should be accounted for when setting up a problem in EnergyModelsRecedingHorizon:","category":"page"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"The provided case object should be an EMB.Case with problem horizons included in the case object through the misc dictionary using the :horizons key.\nThe case must have its OperationalProfiles covering the full problem horizon, otherwise the last value in the time profile will be repeated.\nThe horizon object must be compatible with the case's TimeStructure.\nThe model object must be of a subtype of RecHorEnergyModel for dispatching purposes.\nThe elements in the problem case must have AbstractInitData objects in their data fields where applicable. This is a necessity for all Storage nodes that utilize the new behavior RecedingAccumulating which should be utilized irrespectively of the individual storage node. This initial data must be used to define the first operational period (see the initialization section for more details).","category":"page"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"Contrary to other EnergyModelsX packages, the current package does not solve a single optimization problem, but it solves a sequence of optimization problems. Therefore, the function run_model_rh returns the overall results in a DataFrame format, containing only results related to the implementation horizons of the model.","category":"page"},{"location":"how-to/use-emrh/#how_to-use_emrh-POIext","page":"Use the package","title":"ParametricOptInterface extension","text":"","category":"section"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"If one wants to use the ParametricOptInterface extension, the following adjustments must be made. The only supported type for horizons is PeriodHorizons (please refer to the horizons section). Additionally, the optimizer provided to run_model_rh must be a POI.Optimizer object.","category":"page"},{"location":"how-to/use-emrh/#how_to-use_emrh-EMGExt","page":"Use the package","title":"EnergyModelsGeography extension","text":"","category":"section"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"The basic version includes as well extensions that are loaded if you utilize EnergyModelsGeography. The first extensions provides support for utilizing both Areas and Transmission corridors, including  TransmissionModes. The second extension provides a minor update to a function of EnergyModelsGeography when ParametricOptInterface is utilized.","category":"page"},{"location":"how-to/use-emrh/","page":"Use the package","title":"Use the package","text":"In general, you do not have to take any specific precautions when using EnergyModelsGeography and EnergyModelsRecedingHorizon. However, if you use the transmission mode PipeLinepackSimple, you must provide initialization data through the type TransInitData. Similarly, if you have individual dynamic states in developed transmission modes, you must utilize the same initialization data as well.","category":"page"},{"location":"manual/quick-start/#man-quick","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nMake sure that the registries are updated to include the iDesignRES folder\nInstall the package EnergyModelsRecedingHorizon by running:\n] add EnergyModelsRecedingHorizon","category":"page"},{"location":"library/internals/methods-EMB/#lib-int-met_emb","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-idx","page":"Methods - EnergyModelsBase","title":"Index","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"Pages = [\"methods-EMB.md\"]","category":"page"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-ext","page":"Methods - EnergyModelsBase","title":"Extension methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.objective_operational\nEnergyModelsBase.emissions_operational\nEnergyModelsBase.constraints_elements\nEnergyModelsBase.constraints_couple\nEnergyModelsBase.previous_level","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.objective_operational","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.objective_operational","text":"EMB.objective_operational(m, ùí±::Vector{<:FutureValue}, ùíØ·¥µ‚Åø·µõ::TS.AbstractStratPers, modeltype::EnergyModel)\n\nCreate JuMP expressions indexed over the investment periods ùíØ·¥µ‚Åø·µõ for different elements. The expressions correspond to the operational expenses of the different elements. The expressions are not discounted and do not take the duration of the investment periods into account.\n\nBy default, objective expressions are included for:\n\nùí≥ = ùí±::Vector{<:FutureValue}. In the case of a vector of FutureValue, the method returns the sum of the future value types as extracted through the function get_future_value_expression.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.emissions_operational","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.emissions_operational","text":"EMB.emissions_operational(m, ùí±::Vector{<:FutureValue}, ùí´·µâ·µê, ùíØ, modeltype::EnergyModel)\n\nCreate JuMP expressions indexed over the operational periods ùíØ for different elements. The expressions correspond to the total emissions of a given type.\n\nBy default, emissions expressions are included for:\n\nùí≥ = ùí±::Vector{<:FutureValue}. In the case of a vector of FutureValue, the method returns a value of 0 for all operational periods and emission resources.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_elements","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_elements","text":"EMB.constraints_elements(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùí´, ùíØ, modeltype::EnergyModel)\n\nLoop through all entries of the elements vector and call a subfunction for creating the internal constraints of the entries of the elements vector.\n\nFutureValue - the subfunction is create_future_value.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_couple","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_couple","text":"EMB.constraints_couple(m, ùí±::Vector{<:FutureValue}, ùí´, ùíØ, modeltype::EnergyModel)\n\nCreates the couple constraints for FutureValue elements. The current implementation only creates couplings for the sub-type StorageValueCuts by calling the function create_future_value_couple.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.previous_level","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.previous_level","text":"EMB.previous_level(\n    m,\n    n::Storage{RecedingAccumulating},\n    prev_pers::PreviousPeriods{<:NothingPeriod, Nothing, Nothing},\n    cyclic_pers::CyclicPeriods,\n    modeltype::EnergyModel,\n)\n\nWhen the previous operational and representative period are Nothing and the storage node has the parameter type RecedingAccumulating, the function returns the initial level value (defined externally at the data field through an AbstractInitData object).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-var","page":"Methods - EnergyModelsBase","title":"Variable methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.variables_capacity\nEnergyModelsBase.variables_flow\nEnergyModelsBase.variables_opex\nEnergyModelsBase.variables_capex\nEnergyModelsBase.variables_element\nEnergyModelsBase.variables_emission","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_capacity","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_capacity","text":"EMB.variables_capacity(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel)\n\nDeclaration of functions to add capacity variables for FutureValue elements.\n\nnote: FutureValue\nNo variables are added.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_flow","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_flow","text":"EMB.variables_flow(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel)\n\nDeclaration of functions to add flow variables for FutureValue elements.\n\nnote: FutureValue\nNo variables are added\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_opex","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_opex","text":"EMB.variables_opex(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel)\n\nDeclaration of functions to add OPEX variables for FutureValue elements.\n\nfuture_value[ùí±] variables for all FutureValue in the model reflecting the value of the storages at the end of the optimization period.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_capex","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_capex","text":"EMB.variables_capex(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùíØ, modeltype::EnergyModel)\n\nDeclaration of functions to add CAPEX variables for FutureValue elements.\n\nnote: FutureValue\nNo variables are added\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_element","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_element","text":"EMB.variables_element(m, ùí±::Vector{<:FutureValue}, ùíØ, modeltype::EnergyModel)\n\nDefault fallback method for a vector of elements if no other method is defined for a given vector type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_emission","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_emission","text":"EMB.variables_emission(m, ùí±::Vector{<:FutureValue}, ùí≥·µõ·µâ·∂ú, ùí´, ùíØ, modeltype::EnergyModel)\n\nDeclaration of functions to add emission variables for FutureValue elements.\n\nnote: FutureValue\nNo variables are added\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-fun_field","page":"Methods - EnergyModelsBase","title":"Functions for accessing different information","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"The following functions are introduced for UpdateCase types. They extract the updated value.","category":"page"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.get_products\nEnergyModelsBase.get_elements_vec\nEnergyModelsBase.get_nodes\nEnergyModelsBase.get_links","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.get_products","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.get_products","text":"EMB.get_products(ùí∞::UpdateCase)\n\nMethod for the EnergyModelsBase function to extract the new Resources of the individual ProductSub types.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.get_elements_vec","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.get_elements_vec","text":"EMB.get_elements_vec(ùí∞::UpdateCase)\n\nMethod for the EnergyModelsBase function to extract the new vector of element vectors ùí≥·µõ·µâ·∂ú of UpdateCase ùí∞.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.get_nodes","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.get_nodes","text":"EMB.get_nodes(ùí∞::UpdateCase)\n\nMethod for the EnergyModelsBase function to extract the new Nodes of the individual NodeSub types of UpdateCase ùí∞.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.get_links","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.get_links","text":"EMB.get_links(ùí∞::UpdateCase)\n\nMethod for the EnergyModelsBase function to extract the new Links of the individual LinkSub types of UpdateCase ùí∞.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"dev-notes/code-structure/#dev-code","page":"Code structure","title":"Code structure","text":"","category":"section"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"EnergyModelsRecedingHorizon is based on setting up optimization subproblems given implementation and optimization horizons. The horizons for the optimization subproblems are expressed through AbstractHorizons objects, see the dedicated section on horizons. These will ultimately define how many optimization subproblems will be solved and how large they will be.","category":"page"},{"location":"dev-notes/code-structure/#dev-code-gen","page":"Code structure","title":"General concept","text":"","category":"section"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"For every iteration over the horizons, the optimization subproblem needs to be updated for the time-dependent fields. This is done through AbstractPath objects, whose aim is to automatically identify the model variables that need updating. Each AbstractPath object corresponds to a field in the model structure to be updated. The creation of the accessors to these fields (known as lenses) is done through AbstractReset objects, allowing for type checking of the fields to be updated. This object must always be created through ResetType constructors. The element subject to updating is wrapped around an AbstractSub object, where the original (full-problem) and new (receding horizon) instances of the element are included as fields, as well as the AbstractReset objects linked to the element. A unified constructor, Substitution, is used within the model.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"As a general rule, the fields that require updating are either related to the initial conditions of the system or to the time profiles that the system is subject to. For updating the time profiles, we read the originally provided time profile for the full optimization problem. As for the initial conditions of the system, each element is assumed to be independently initializable through their own variables. Initialization of the system is therefore done at the element level, which we describe in more detail in the dedicated page on initialization.","category":"page"},{"location":"dev-notes/code-structure/#dev-code-res_type","page":"Code structure","title":"Implemented reset types","text":"","category":"section"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"The individual reset types correspond to fields of an element that should be replaced. The reset types have as individual fields","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"lens representing the lens pointing towards the field in the type,\nvar corresponding to the parameter variable when using ParametricOptInterface, and\nval is the value which is used in the resets. Its meaning differs depending on the individual reset type.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"EnergyModelsRecedingHorizon implements the following standard reset types:","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"OperReset with OperPath: A reset type pointing towards a field with OperationalProfile.\nThe field val corresponds to the operational profile of the full time structure, not the profile of the individual horizon.\nElementReset with ElementPath: A reset type pointing towards a field with an AbstractElement.\nThe field val corresponds to the instance of the element of the original case type.\nTimeWeightReset with TimeWeightPath: A reset type for a time weight of a FutureValue.\nThe field val is updated at the beginning of each iteration according to the optimization horizon end time.\nInitReset with AbstractInitDataPath: A reset type pointing towards fields of initial data.\nIn addition, it has the AbstractInitDataPath instance as second field. The field val is updated after each optimization iteration with the extracted value from the optimization results.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"All reset types utilize an inner constructor for creating the lens in their construction. Furthermore, all reset types are constructed only through the function EMRH.ResetType.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"tip: New reset types\nWhile the core structure includes the majority of the required reset types, it can be necessary to create new reset types. In this case, you must create:a subtype to AbstractPath,\na subtype to EMRH.AbstractReset,\na new method for the function ResetType using the same arguments order,\na new method for the function EMRH._find_update_paths, and\na new method for the function EMRH._reset_field and its POI extension.In general, it should not be necessary to create a new reset type as we simplified the approach for initialization data through the utilization of a parametric type.","category":"page"},{"location":"dev-notes/code-structure/#dev-code-sub_type","page":"Code structure","title":"Implemented substitution types","text":"","category":"section"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"Substitution types unify all resets within an AbstractElement. All substitution types are parametric on the element type and have the fields","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"new representing the new element instance that is used in the case for analysis,\norg representing the original element instance from the original case structure, and\nresets::Vector{<:AbstractReset} including all AbstractResets that are relevant for the given type.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"They are constructed through the function EMRH.Substitution.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"EnergyModelsRecHorizon implements the following standard reset types:","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"ModelSub for resetting fields in the model type,\nProductSub for resetting fields in Resources,\nNodeSub for resetting fields in Node,\nLinkSub for resetting fields in Link, and\nFutureValueSub for resetting fields in FutureValue.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"The extension for EnergyModelsGeography adds the following additional reset types:","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"AreaSub for resetting fields in Areas and\nTransmissionSub for resetting fields in Transmission corridors.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"tip: New `AbstractElement`s\nIf your EnergyModelsBase extension introduces new AbstractElements, you must provide:a subtype to EMRH.AbstractSub,\na method to the function EMRH._ele_to_sub, and\na method for your function for extracting the AbstractElement from the UpdateCase, see, e.g., EMB.get_nodes.Depending on the structure of your AbstractElement, it can be furthermore necessary to provide new methods to the functions EMRH.original and EMRH.updated.","category":"page"},{"location":"dev-notes/code-structure/#dev-code-int_flow","page":"Code structure","title":"Internal work flow","text":"","category":"section"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"While the internal work flow is in general the same whether you use ParametricOptInterface or not, there are some differences in the individual function flow. The following section provides the general overview with differentiation between the individual implementations.","category":"page"},{"location":"dev-notes/code-structure/","page":"Code structure","title":"Code structure","text":"The UpdateCase is first created for all elements through the functions EMRH._create_updatetype and EMRH._add_elements!. These functions create the individual substitution and reset types including the relevant lenses. The functions are agnostic whether you use ParametricOptInterface or not.\nnote: POI implementation\nThe POI implementation requires as additional step the initialization of the JuMP model through calling the function create_model to avoid constructing the model in every single iteration. To this end, the specific case and model are initialized through the function POIExt._init_update_case! in which the first horizon is used for the initialization of the optimization problem and the creation of the additional auxiliary variables required for the parameters.\nThe individual elements with AbstractInitData are identified to avoid iterating through all elements in each iteration of the receding horizon framework. In addition, we rearrange the FutureValue substitution types for simplified later updating.\nThe algorithm iterates through all horizons sequentially and solves the optimization problem.\nIf the system includes FutureValue types, we update FutureValues whose weight is dependent on the elapsed time using the function EMRH._update_future_value!. This is for example the case for StorageValueCuts.\nThe second step is different in the two implementations.\ntip: Standard implementation\nIn the standard implementation, we first update the UpdateCase created in the first step through the function EMRH._update_update_case! and subsequently extract from the UpdateCase both the model and case required for creating an EMX model. Subsequently, we create the JuMP model through calling the function create_model.\nnote: POI implementation\nIn the POI implementation, we only have to update the values of the created parameter variables through the function POIExt.update_model!.\nSubsequently, the model is optimized.\nOnce the model is solved, the operational results for the implementation horizon are extracted from the model and saved as a DataFrame through the function EMRH.update_results!. Variables that are indexed with strategic periods are not extracted.\nThe value of the reset type for initialization data is updated using the results from the optimization problem using the function EMRH.update_init_data!.","category":"page"},{"location":"dev-notes/future_value/#dev-fv","page":"Future value implementation","title":"Implementation of future values","text":"","category":"section"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"As outlined on the page Storage end values, we implemented a new AbstractElement for representing the future value in dynamic constraints. So far, one subtype is implemented through StorageValueCuts. It is however possible to provide new subtypes representing different implementations for calculating or constraining a future value.","category":"page"},{"location":"dev-notes/future_value/#dev-fv-fun_flow","page":"Future value implementation","title":"Function flow for incorporating future values","text":"","category":"section"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"As mentioned, FutureValue is implemented as subtype of AbstractElement. This implies that the package must provide methods for a variety of individual functions from EnergyModelsBase.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"The new methods for variable creation are","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"EMB.variables_capacity, not incorporating any new variable,\nEMB.variables_flow, not incorporating any new variable,\nEMB.variables_opex, incorporating the new variable textttfuture_value(v)  forall v in V,\nEMB.variables_element, not incorporating any new variable, and\nEMB.variables_emission, not incorporating any new variable.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"This implies that we currently only include a single additional variable for the future value, textttfuture_value(v). This variable is created for all subtypes of FutureValue.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"The individual constraints are added through the methods","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"EMB.constraints_elements, calling the subfunction EMRH.create_future_value,\nEMB.constraints_couple, calling the subfunction EMRH.create_future_value_couple,\nEMB.emissions_operational, returning a JuMP expression of 0 with the required indices as FutureValues do not result in emissions, and\nEMB.objective_operational, calling the subfunction EMRH.get_future_value_expression.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"There are two things to highlight in this design:","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"the default method for EMRH.create_future_value does not create any constraints and\nEMRH.create_future_value_couple is only declared for StorageValueCuts.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"Point 1 implies that the variable textttfuture_value(v) does not have any internal constraints by default. It is instead constrained for the implementation of StorageValueCuts through the function EMRH.create_future_value_couple. The thought process behind this approach is that StorageValueCuts are constrained through Storage nodes. It is hence a constraints_couple constraint, even if the function has only a single input, ùí±::Vector{<:FutureValue}.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"We furthermore decided to split the overall contribution to the cost function in the current design into additional subfunctions through EMRH.get_future_value_expression for the individual supertypes. While this is not strictly necessary, it is one approach for differentiating between subtypes of FutureValue.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"Within the concept of EnergyModelsRecedingHorizon, we added as well an additional function EMRH._update_future_value! for updating parameters of the FutureValue before each optimization run.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"warning: Default methods\nWe do not include default methods for the subfunctions. These subfunctions are EMRH.create_future_value_couple and EMRH.get_future_value_expression. As a consequence, you must declare them for your new type.The philosophy here is that it is preferable that the developer of new methods receives a method error instead of no error when he implements a wrong method.","category":"page"},{"location":"dev-notes/future_value/#dev-fv-new","page":"Future value implementation","title":"Requirements for new future values","text":"","category":"section"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"It is possible to create new FutureValues. This requires a combination of new types and new metods. The following steps must be conducted to incorporate a new type:","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"Create a new type as composite type:\nstruct NewFutureValue <: FutureValue\n    id::Any\nend\nIt can include as many fields as desired, but it 1. must include the field id and 2. cannot include a dictionary in which a Node is a key (you may use ElementValue instead if necessary).\nCreate a new method for the function EMRH.create_future_value_couple for your NewFutureValue. In general, you should have the corresponding Node as field of your NewFutureValue. If this is not the case, e.g., through assigning the same future value for all instances of a given variable of a type, it is necessary to provide new methods for EMB.constraints_couple which also includes a potentially empty method for FutureValue.\nCreate a new method for the function EMRH.get_future_value_expression which returns a JuMP expression indexed over the strategic periods which corresponds to the contribution to the cost function.\nCreate a new method for the function EMRH._update_future_value!. This function is used for updating potential fields that are dependent on the elapsed time before the optimization problem is solved. If the future value for your NewFutureValue is independent of the elapsed time, you can provide an empty method.","category":"page"},{"location":"dev-notes/future_value/","page":"Future value implementation","title":"Future value implementation","text":"tip: Additional variables and internal constraints\nIf your NewFutureValue requires additional variables, you can create a new method for EMB.variables_element. These variables will then be accessible in all potential subsequent functions. If you have internal constraints, that is constraints only accessing variables indexed over Vector{<:NewFutureValue>}, you must create a new method for EMRH.create_future_value and add these constraints in this function.","category":"page"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"","category":"section"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-idx","page":"Internals - ParametricOptInterface extension","title":"Index","text":"","category":"section"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"Pages = [\"reference-POIExt.md\"]","category":"page"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"CurrentModule =\n    Base.get_extension(EMRH, :POIExt)","category":"page"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-ext","page":"Internals - ParametricOptInterface extension","title":"Extension","text":"","category":"section"},{"location":"library/internals/reference-POIExt/#lib-POIExt-ext-util","page":"Internals - ParametricOptInterface extension","title":"Utility functions","text":"","category":"section"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"_init_update_case!\nupdate_model!","category":"page"},{"location":"library/internals/reference-POIExt/#POIExt._init_update_case!","page":"Internals - ParametricOptInterface extension","title":"POIExt._init_update_case!","text":"_init_update_case!(m, ùí∞, opers, ùíØ·µ£‚Çï)\n\nInitialize the JuMP model m and the UpdateCase ùí∞ with the anonymous variables corresponding to the inidividual fields of all types whose value(s) change(s).\n\nIn addition, the UpdateCase ùí∞ is updated with the new mapping between the operational periods of the optimization (through ùíØ·µ£‚Çï) and the original (through opers) problem.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-POIExt/#POIExt.update_model!","page":"Internals - ParametricOptInterface extension","title":"POIExt.update_model!","text":"update_model!(m, ùí∞, opers, ùíØ·µ£‚Çï)\n\nUpdate the JuMP model m with the new values given by the vector of operational periods of the original problem opers.\n\nIn addition, the UpdateCase ùí∞ is updated with the new mapping between the operational periods of the optimization (through ùíØ·µ£‚Çï) and the original (through opers) problem.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"_update_parameter_values!\n_update_parameter!(m, res_type::EMRH.ElementReset, opers::Vector)","category":"page"},{"location":"library/internals/reference-POIExt/#POIExt._update_parameter_values!","page":"Internals - ParametricOptInterface extension","title":"POIExt._update_parameter_values!","text":"_update_parameter_values!(m, ùíÆ::Vector{<:AbstractSub}, opers::Vector{<:TS.TimePeriod})\n_update_parameter_values!(m, s:::AbstractSub, opers::Vector{<:TS.TimePeriod})\n\nUpdates the parameters from m with the values within the Vector{<:AbstractSub} or AbstractSub indexed by opers. The update only takes place when the field resets of a given AbstractSub is not empty. In this case, the subroutine _update_parameter! is called to set the parameter to the new value.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-POIExt/#POIExt._update_parameter!-Tuple{Any, EnergyModelsRecedingHorizon.ElementReset, Vector}","page":"Internals - ParametricOptInterface extension","title":"POIExt._update_parameter!","text":"_update_parameter!(m, res_type::ElementReset, opers::Vector)\n_update_parameter!(m, res_type::OperReset, opers::Vector)\n_update_parameter!(m, res_type::InitReset{EMRH.InitDataPath}, opers::Vector)\n_update_parameter!(m, res_type::TimeWeightReset, opers::Vector)\n\nSet the parameter value in m for a given res_type:\n\nres_type::ElementReset results in no update,\nres_type::InitReset{EMRH.InitDataPath} updates the value directly from res_type,\nres_type::TimeWeightReset updates the value directly from res_type,\nres_type::OperReset creates a new operational profile based on the original operational profile and the set of operational periods in opers, updating each parameter with it.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-EMRH","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsRecedingHorizon","text":"","category":"section"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-EMRH-exp_met","page":"Internals - ParametricOptInterface extension","title":"Exported methods","text":"","category":"section"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"Because the receding horizon implementation using ParametricOptInterface relies on pre-allocation of the input parameters for time profiles, its use is only allowed with PeriodHorizons, as it is a horizon type that preserves the length of the input time profiles.","category":"page"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"EMRH.run_model_rh(case::AbstractCase, model::EMRH.RecHorEnergyModel, optimizer::POI.Optimizer; check_timeprofiles::Bool = true)","category":"page"},{"location":"library/internals/reference-POIExt/#EnergyModelsRecedingHorizon.run_model_rh-Tuple{AbstractCase, EnergyModelsRecedingHorizon.RecHorEnergyModel, ParametricOptInterface.Optimizer}","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsRecedingHorizon.run_model_rh","text":"EMRH.run_model_rh(case::AbstractCase, model::EMRH.RecHorEnergyModel, optimizer::POI.Optimizer; check_timeprofiles::Bool = true)\n\nWhen the optimizer is a ParametricOptInterface.Optimizer type, it utilizes ParametricOptInterface (POI) for resetting the individual values.\n\nwarning: Using POI\nWhen using POI, the horizon type must be a PeriodHorizons type with each individual horizon having the same durations for its periods. This is checked using an @assert macro.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-EMRH-int_met","page":"Internals - ParametricOptInterface extension","title":"Internal methods","text":"","category":"section"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"EMRH._update_case_types!(m, ùíÆ::Vector{<:EMRH.AbstractSub}, ùí∞::EMRH.UpdateCase, ùíØ·¥ø·¥¥::TimeStructure)\nEMRH._reset_field(m, x_rh, res_type::EMRH.ElementReset, ùí∞::EMRH.UpdateCase, ùíØ·¥ø·¥¥::TimeStructure)","category":"page"},{"location":"library/internals/reference-POIExt/#EnergyModelsRecedingHorizon._update_case_types!-Tuple{Any, Vector{<:EnergyModelsRecedingHorizon.AbstractSub}, EnergyModelsRecedingHorizon.UpdateCase, TimeStructure}","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsRecedingHorizon._update_case_types!","text":"EMRH._update_case_types!(m, ùíÆ::Vector{<:AbstractSub}, ùí∞::UpdateCase, opers::Vector{<:TS.TimePeriod})\nEMRH._update_case_types!(m, s:::AbstractSub, ùí∞::UpdateCase, opers::Vector{<:TS.TimePeriod})\n\nUpdates the elements within the Vector{<:AbstractSub} or AbstractSub with the new values, The update only takes place when the field reset of a given AbstractSub is not empty. In this case, the subfunction _reset_field is called.\n\nThe variables for ParametricOptInterface are saved in the model m.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-POIExt/#EnergyModelsRecedingHorizon._reset_field-Tuple{Any, Any, EnergyModelsRecedingHorizon.ElementReset, EnergyModelsRecedingHorizon.UpdateCase, TimeStructure}","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsRecedingHorizon._reset_field","text":"EMRH._reset_field(m, x_rh, res_type::ElementReset, ùí∞::UpdateCase, ùíØ·¥ø·¥¥::TimeStructure)\nEMRH._reset_field(m, x_rh, res_type::Union{InitReset,TimeWeightReset}, ùí∞::UpdateCase, ùíØ·¥ø·¥¥::TimeStructure)\nEMRH._reset_field(m, x_rh, res_type::OperReset, ùí∞::UpdateCase, ùíØ·¥ø·¥¥::TimeStructure)\n\nResets the field expressed through res_type of element x_rh with the new value. The type of the new value is depending on the specified res_type:\n\nres_type::ElementReset uses ùí∞ for identifying the new element and does not create new parameters,\nres_type::InitReset and res_type::TimeWeightReset create a single new MOI parameter and resets the field with it,\nres_type::OperReset creates multiple MOI parameters and a new operational profile based on the original operational profile, and resets the field with it.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-POIExt/#lib-int-POIExt-EMB","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsBase","text":"","category":"section"},{"location":"library/internals/reference-POIExt/","page":"Internals - ParametricOptInterface extension","title":"Internals - ParametricOptInterface extension","text":"EMB.constraints_capacity_installed","category":"page"},{"location":"library/internals/reference-POIExt/#EnergyModelsBase.constraints_capacity_installed","page":"Internals - ParametricOptInterface extension","title":"EnergyModelsBase.constraints_capacity_installed","text":"EMB.constraints_capacity_installed(m, n::Node, ùíØ::TimeStructure, modeltype::RecHorEnergyModel)\nEMB.constraints_capacity_installed(m, n::Storage, ùíØ::TimeStructure, modeltype::RecHorEnergyModel)\nEMB.constraints_capacity_installed(m, l::Link, ùíØ::TimeStructure, modeltype::RecHorEnergyModel)\n\nWhen modeltype is a receding horizon model, the function utilizes constraints instead of the function JuMP.fix for constraining the capacity as it is not possible to fix to a POI parameter.\n\ninfo: Fixed variables\nFixing variables is not possible if the parameter is a POI parameter. It is instead necessary to utilize constraints. Improved speed can be achieved by calling# before the constraint\nMOI.set(m, POI.ConstraintsInterpretation(), POI.ONLY_BOUNDS)\n# and\nMOI.set(m, POI.ConstraintsInterpretation(), POI.ONLY_CONSTRAINTS)\n# after the constraint.\n\n\n\n\n\n","category":"function"},{"location":"manual/philosophy/#man-phil","page":"Philosophy","title":"Philosophy","text":"","category":"section"},{"location":"manual/philosophy/#man-phil-rechor","page":"Philosophy","title":"What is a receding horizon?","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Receding horizon refers to a method for solving dynamic optimization problems where smaller dynamic optimization problems are solved repeatedly over changing horizons, which are updated based on previous solutions and new observations. It is inspired by model predictive control (MPC), also known as receding horizon control [1], where a control problem is defined by a dynamic optimization problem. This problem is solved for a finite time horizon, the first calculated control action is implemented in the system, and a new dynamic optimization problem is formulated based on the new state of the system after implementing the control actions.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"Here, we use the receding horizon concept to reduce the complexity of a full-scale optimization problem into smaller subproblems. Each subproblem is solved over a finite time horizon (here denoted optimization horizon). The solution for this subproblem is stored for a usually smaller time horizon (here denoted implementation horizon), and the next subproblem is posed to begin at the end of this implementation horizon, see illustration below. Note that the individual operational periods do not need to have the same length.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"(Image: Illustration of receding horizon)","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"This package is an extension of the core EnergyModelsBase structure, and therefore it follows the same principles of flexibility, extendability, and transparency (see the EnergyModelsBase page on its philosophy).","category":"page"},{"location":"manual/philosophy/#man-phil-hortyp","page":"Philosophy","title":"Types of horizons","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"This package is based on setting up optimization subproblems given implementation and optimization horizons, as described above. How these horizons are defined and updated will dictate the behavior of the receding horizon solver. The behavior of these horizons is considered as an abstract type AbstractHorizons, allowing for common treatment of these approaches. Two horizon types are provided with EnergyModelsRecedingHorizon, as subtypes of AbstractHorizons:","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"PeriodHorizons: the original time structure is partitioned according to the number of operational periods. This means that each implementation and optimization horizons are of the same length across the optimization subproblems.\nDurationHorizons: the original time structure is partitioned according to the duration of the operational periods. This means that each implementation and optimization horizons may have varying length across the optimization subproblems. Because the model processes an integer number of operational periods at any given iteration, the duration of each implementation and optimization horizon may be slightly bigger than pre-defined.","category":"page"},{"location":"manual/philosophy/#man-phil-func","page":"Philosophy","title":"Functionalities for receding horizon optimization","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"To solve optimization problems in a receding horizon framework, additional functionalities must be present in the problem. These functionalities are implemented and are compatible with elements introduced in EnergyModelsBase and EnergyModelsGeography.","category":"page"},{"location":"manual/philosophy/#man-phil-func-init","page":"Philosophy","title":"Initialization of elements","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"As the optimization horizon moves forward in the receding horizon iterations, the initial states of the model must be updated. This is especially relevant for dynamic elements such as Storage nodes, where the state at a given time depends on previous operation. The basic functionality is implemented through InitData objects. With it, one can define the value of the related model variables at the start of the current optimization horizon. These functionalities can be extended through additional subtypes of AbstractInitData.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"For more implementation details, see the developer notes section on initialization.","category":"page"},{"location":"manual/philosophy/#man-phil-func-fv","page":"Philosophy","title":"Future value descriptions","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"In some cases, it is necessary to use future value descriptions for dynamic states in receding horizon optimization. This is done to obtain solutions for the smaller problems that are compatible with the full-horizon behavior. The package provides a future value description based on the concept of storage end value [2], which introduces penalties related to the value of the outgoing state at the end of each individual optimization problem.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"For a detailed description of this feature, refer to the section on storage end values. The implementation is furthermore explained in the development notes","category":"page"},{"location":"manual/philosophy/#man-phil-when","page":"Philosophy","title":"When should you use the package?","text":"","category":"section"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The package is intended for use in complex optimization problems in which it is not feasible to model a complete operational horizon in a single optimization run. In these problems, the solution of smaller problems sequentially in time may allow tractability of the problem.","category":"page"},{"location":"manual/philosophy/","page":"Philosophy","title":"Philosophy","text":"The package is implemented with focus on calculating supply-demand balances for systems in an operational time scale and does not support investment analysis. In addition, the calculation of operational costs for full periods is not yet implemented, although these can be calculated with the existing information.","category":"page"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-idx","page":"Internals - EnergyModelsGeography extension","title":"Index","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"Pages = [\"reference-EMGExt.md\"]","category":"page"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMRH","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMRH-typ","page":"Internals - EnergyModelsGeography extension","title":"Types","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"The following types are introduced for providing initial data for TransmissionModes. Only PipeLinepackSimple supports at the moment initial data.","category":"page"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMGExt.TransInitData\nEMGExt.TransInitDataPath","category":"page"},{"location":"library/internals/reference-EMGExt/#EMGExt.TransInitData","page":"Internals - EnergyModelsGeography extension","title":"EMGExt.TransInitData","text":"TransInitData{T} <: AbstractInitData\n\nInitialization data type for TransmissionMode. It follows the same structure as the standard InitData, that is it is using a single value for a given variable. Multiple variables can be initialized simultaneously.\n\nIt is required as the indexing is different  for TransmissionModes compared to Nodes, Links, or Areas.\n\nFields\n\ninit_val_dict::Dict{Symbol,T} is a dictionary with the variable symbol as key and the value in the beginning of the analysis as value.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference-EMGExt/#EMGExt.TransInitDataPath","page":"Internals - EnergyModelsGeography extension","title":"EMGExt.TransInitDataPath","text":"struct TransInitDataPath <: AbstractInitDataPath\n\nInternal type for paths pointing towards TransInitData.\n\nFields\n\nidx::Int is the index of the mode within the associated Transmission corridor.\nkey::Symbol is the key in the TransInitData (and correspondingly in the JuMP model).\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"The following functions are included for extracting the values from a TransmissionMode and initial data type:","category":"page"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"data_init(a::Area)\nEMRH.model_key(idp::EMGExt.TransInitDataPath)","category":"page"},{"location":"library/internals/reference-EMGExt/#EnergyModelsRecedingHorizon.data_init-Tuple{Area}","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon.data_init","text":"EMRH.data_init(a::Area)\nEMRH.data_init(l::Transmission)\nEMRH.data_init(tm::TransmissionMode)\n\nReturns initialization data for Transmission corridor l or TransmissionMode tm. In the case of a Transmission corridor, it returns all initialization data as Vector.\n\nIn the case of an Area a, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-EMGExt/#EnergyModelsRecedingHorizon.model_key-Tuple{EMGExt.TransInitDataPath}","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon.model_key","text":"model_key(idp::TransInitDataPath)\n\nReturns the model key (field key) of TransInitDataPath idp.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"In addition, we provide a new method for the identification of initial data:","category":"page"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMRH.has_init(a::Area)","category":"page"},{"location":"library/internals/reference-EMGExt/#EnergyModelsRecedingHorizon.has_init-Tuple{Area}","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon.has_init","text":"EMRH.has_init(a::Area)\nEMRH.has_init(l::Transmission)\nEMRH.has_init(tm::TransmissionMode)\n\nChecks whether the Transmission corridor l or TransmissionMode tm has initialization data.\n\nIn the case of an Area a, it returns false.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"The following types are introduced for the resetting of the fields","category":"page"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMGExt.AreaSub\nEMGExt.TransmissionSub","category":"page"},{"location":"library/internals/reference-EMGExt/#EMGExt.AreaSub","page":"Internals - EnergyModelsGeography extension","title":"EMGExt.AreaSub","text":"mutable struct AreaSub{T<:Area} <: AbstractSub\n\nAbstractSub for Areas.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given Area.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference-EMGExt/#EMGExt.TransmissionSub","page":"Internals - EnergyModelsGeography extension","title":"EMGExt.TransmissionSub","text":"mutable struct TransmissionSub{T<:Transmission} <: AbstractSub\n\nAbstractSub for Transmission corridor.\n\nFields\n\nnew::T is the new instance after resetting its values.\norg::T is the original instance before resetting its values.\nresets::Vector{<:AbstractReset} are AbstractReset types for the given Transmission corridor.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMRH-int_met","page":"Internals - EnergyModelsGeography extension","title":"Internal methods","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMRH._find_update_paths(field::Vector{T}, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}\nEMRH.update_init_data!(m, ri::EMRH.AbstractReset, l::Transmission, idp::EMGExt.TransInitDataPath, opers_impl·µ£‚Çï)","category":"page"},{"location":"library/internals/reference-EMGExt/#EnergyModelsRecedingHorizon._find_update_paths-Union{Tuple{T}, Tuple{Vector{T}, Vector{Any}, Vector{Any}}} where T<:TransmissionMode","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon._find_update_paths","text":"EMRH._find_update_paths(field::Vector{T}, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}\nEMRH._find_update_paths(field::T, current_path::Vector{Any}, all_paths::Vector{Any}) where {T<:TransmissionMode}\nEMRH._find_update_paths(field::TransInitData, current_path::Vector{Any}, all_paths::Vector{Any})\n\nThe function _find_update_paths requires new methods for the geography extension as\n\nTransmissionModes are not included in the default methods and\nTransInitData requires a separate method for the given path.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-EMGExt/#EnergyModelsRecedingHorizon.update_init_data!-Tuple{Any, EnergyModelsRecedingHorizon.AbstractReset, Transmission, EMGExt.TransInitDataPath, Any}","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsRecedingHorizon.update_init_data!","text":"EMRH.update_init_data!(m, ri::AbstractReset, l::Transmission, idp::TransInitDataPath, opers_impl·µ£‚Çï)\n\nUpdates the initial values of Transmission  corridor l for the AbstractReset ri with the value specified by the key of the TransInitDataPath idp.\n\nThe mode for the variable is identified through the field idx of TransInitDataPath.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMG","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsGeography","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMG-con","page":"Internals - EnergyModelsGeography extension","title":"Constraint functions","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMG.constraints_trans_balance\nEMG.constraints_capacity_installed","category":"page"},{"location":"library/internals/reference-EMGExt/#EnergyModelsGeography.constraints_trans_balance","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsGeography.constraints_trans_balance","text":"EMG.constraints_trans_balance(m, tm::PipeLinepackSimple, ùíØ::TimeStructure, modeltype::RecHorEnergyModel)\n\nThe calculation of the transmission balance differs for PipeLinepackSimple in the receding horizon implementation as we do not utilize cyclic constraints. Instead, it extracts the value from the TransInitData.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-EMGExt/#EnergyModelsGeography.constraints_capacity_installed","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsGeography.constraints_capacity_installed","text":"EMG.constraints_capacity_installed(m, tm::TransmissionMode, ùíØ::TimeStructure, modeltype::RecHorEnergyModel)\n\nWhen modeltype is a receding horizon model, the function utilizes constraints instead of the function JuMP.fix for constraining the capacity as it is not possible to fix to a POI parameter.\n\ninfo: Fixed variables\nFixing variables is not possible if the parameter is a POI parameter. It is instead necessary to utilize constraints. Improved speed can be achieved by calling# before the constraint\nMOI.set(m, POI.ConstraintsInterpretation(), POI.ONLY_BOUNDS)\n# and\nMOI.set(m, POI.ConstraintsInterpretation(), POI.ONLY_CONSTRAINTS)\n# after the constraint.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"constraints_capacity_installed only receives a new method if ParametricOptInterface is loaded.","category":"page"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-EMG-fun_field","page":"Internals - EnergyModelsGeography extension","title":"Functions for accessing fields","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"The following functions are introduced for UpdateCase types. They extract the updated value.","category":"page"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"EMG.get_areas\nEMG.get_transmissions","category":"page"},{"location":"library/internals/reference-EMGExt/#EnergyModelsGeography.get_areas","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsGeography.get_areas","text":"get_areas(ùí∞::UpdateCase)\n\nMethod for the equivalent EnergyModelsGeography function to extract the new Areas of the individual AreaSub types of UpdateCase ùí∞.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-EMGExt/#EnergyModelsGeography.get_transmissions","page":"Internals - EnergyModelsGeography extension","title":"EnergyModelsGeography.get_transmissions","text":"get_transmissions(ùí∞::UpdateCase)\n\nMethod for the equivalent EnergyModelsGeography function to extract the new Transmission corridors of the individual TransmissionSub types of UpdateCase ùí∞.\n\nThis element vector can be directly utilized for the field elements of a Case.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/reference-EMGExt/#lib-int-EMGExt-POI","page":"Internals - EnergyModelsGeography extension","title":"ParametricOptInterface","text":"","category":"section"},{"location":"library/internals/reference-EMGExt/","page":"Internals - EnergyModelsGeography extension","title":"Internals - EnergyModelsGeography extension","text":"POIExt._update_parameter!(m, res_type::EMRH.InitReset{EMGExt.TransInitDataPath}, opers::Vector)","category":"page"},{"location":"library/internals/reference-EMGExt/#POIExt._update_parameter!-Tuple{Any, EnergyModelsRecedingHorizon.InitReset{EMGExt.TransInitDataPath}, Vector}","page":"Internals - EnergyModelsGeography extension","title":"POIExt._update_parameter!","text":"POIExt._update_parameter!(m, res_type::InitReset{EMGExt.TransInitDataPath}, opers::Vector)\n\nUpdate the parameter value for a given InitReset{EMGExt.TransInitDataPath} to the provided value of the InitReset type.\n\n\n\n\n\n","category":"method"},{"location":"manual/storage_end_value/#man-sev","page":"Storage end value","title":"Storage end values","text":"","category":"section"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"A new AbstractElement, FutureValue, has been implemented to be able to include additional terms to the objective without adding new nodes to the model. The composite type StorageValueCuts can be used to describe the value of storages at the end of the optimization period as multiple cutting hyperplanes that depend on one or several of the outgoing state variables. For more details about the generation of cuts in stochastic dual dynamic programming we refer to [3].","category":"page"},{"location":"manual/storage_end_value/#man-sev-args","page":"Storage end value","title":"Arguments for StorageValueCuts","text":"","category":"section"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"A StorageValueCuts object includes a weight, a time and a Vector{StorageValueCut}. The weight indicates the factor of the respective StorageValueCuts in the objective function. Cuts are often combined with discrete Markov states such that the resulting storage end value is a weighted sum of several different StorageValueCuts. The time indicates at which time the StorageValueCuts are valid relative to the start time of the optimization problem in a given receding horizon iteration.","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"Each StorageValueCut object is defined by a set of coefficients coeffs, and a constant rhs. The coeffs can be defined by a dictionary with keys s and values w_s, where s denotes a given Storage node for which the cut refers to, and w_s denotes the coefficient for the given cut.","category":"page"},{"location":"manual/storage_end_value/#man-sev-math","page":"Storage end value","title":"Mathematical description","text":"","category":"section"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"Let textttfuture_value denote the future value of storages in a system given by StorageValueCuts. Multiple StorageValueCut elements bound the value of textttfuture_value with linear cutting hyperplanes:","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"beginaligned\n    textttfuture_valuev + sum_s w_s w_s times textttstor_levelst_end leq cut_rhs(c) qquad forall c in C_v v in V\nendaligned","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"where v  V denotes the set of all active StorageValueCuts for a given model, C_v the set of cuts in v, c represents each StorageValueCut in v, and (s w_s) represents the set of coefficients for c in the coeffs field.","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"The following terms are added to objective:","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"beginaligned\n    sum_v in V weight(v) times time_weight(v) times textttfuture_valuev\nendaligned","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"The term weight(v) refers to a constant weight defined for the StorageValueCuts element (field weight). The term time_weight(v) is updated for every StorageValueCuts element along the receding horizon iterations. The only non-zero weights will be related to StorageValueCuts closest in time to the current optimization end time.","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"For example, consider a receding horizon iteration for which the optimization problem ends at 168 time units after the full problem's first operational period. If there exists one or multiple StorageValueCuts objects where time is 168, we use these StorageValueCuts to valuate the storage at the end of the iteration. Otherwise, if the closest StorageValueCuts in both directions are defined at times 160 and 180, we will use a weighted sum of these to cuts as the end value. Currently, a StorageValueCuts must be added for time = 0.","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"Let t_end denote the end time of the optimization relative to the start time. Let t_down and t_up denote the time of the cut(s) nearest to t_end in either directions, and v_down and v_up the corresponding StorageValueCuts. The value of time_weight(v) can be expressed as weighting between the cuts above and below t_end:","category":"page"},{"location":"manual/storage_end_value/","page":"Storage end value","title":"Storage end value","text":"beginaligned\n    time_weight(v_down) = 1 - fract_end - t_downt_up - t_down \n    time_weight(v_up) = 1 - time_weight(v_down)\nendaligned","category":"page"},{"location":"dev-notes/initialization/#dev-init","page":"Problem initialization","title":"Problem initialization","text":"","category":"section"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"Initialization functions are necessary for proper definition of the optimization problem. The initialization of a node must be fully defined by an object of type AbstractInitData. The concrete type InitData is implemented with the expected functionality for most problems. It features a dictionary with the keys being the labels of the states subjected to updates. A standard behavior for InitData is provided, which allows for updating considering that the labeled states can be initialized by their previously calculated values at the corresponding time period, i.e. the last implementation time period. The variables to be read from the model can only be indexed over the associated AbstractElement and TimePeriod.","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"To utilize the AbstractInitData object in the model calculations, additional equations must be provided. That can be done in several ways, and the user is referred to the page on how to adapt EMX elements for examples.","category":"page"},{"location":"dev-notes/initialization/#dev-init-custom","page":"Problem initialization","title":"Custom initialization objects","text":"","category":"section"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"The user that implements new AbstractInitData types must implement methods for the functions that process this object, as well as extra types. The functions to be dispatched upon for a new AbstractInitData are","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"_find_update_paths is the function used to detect the fields in the AbstractInitData object to be updated over changing horizons and\nupdate_init_data! is the function used to update the receding horizon AbstractInitData object based on the solution of the receding horizon problem in a previous time window.","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"These functions are automatically used in the main function run_model_rh, and they can be easily dispatched upon for custom elements.","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"In addition, a new subtype of AbstractInitDataPath associated to the new object must be created. AbstractInitDataPath refers to a subtype of AbstractPath, which serves to identify the model variables that need updating (see the section on the code structure for more details). The standard behavior for this object is implemented in InitDataPath, which simply contains the variable key to be updated.","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"One example for the implementation of a new initial data is given by TransInitData in the EnergyModelsGeography extension and its internal library:","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"TransInitData,\nTransInitDataPath,\nEMRH._find_update_paths,\nEMRH.update_init_data!\nPOIExt._update_parameter!, only required for the ParametricOptInterface extension.","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"The extension POIExt can be accessed for dispatching through","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"using EnergyModelsRecedingHorizon\nusing ParametricOptInterface\n\nconst EMRH = EnergyModelsRecedingHorizon\nconst POIExt = Base.get_extension(EMRH, :POIExt)","category":"page"},{"location":"dev-notes/initialization/","page":"Problem initialization","title":"Problem initialization","text":"warning: New initial data with Vectors and POI\nIf you create a new AbstractInitData in which the values that are reset are vectors (or generally speaking, not single values), you must create a new method EnergyModelsRecedingHorizon._reset_field for the res_type argument for the ParametricOptInterface implementation.An example for a new type VectorInitData (with VectorInitDataPath for identifying the path) is given byfunction EMRH._reset_field(\n    m,\n    x_rh,\n    res_type::InitReset{VectorInitDataPath},\n    ùí∞::UpdateCase,\n    ùíØ·¥ø·¥¥::TimeStructure,\n)\n    val_par = MOI.Parameter.(res_type.val)\n    res_type.var = @variable(m, [eachindex(res_type.val)] ‚àà val_par)\n    @reset res_type.lens(x_rh) = res_type.var\n    return x_rh\nend","category":"page"},{"location":"manual/NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.1.0-(2025-03-27)","page":"Release notes","title":"Version 0.1.0 (2025-03-27)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Initial version of the package:","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Includes a receding horizon framework which can be based on two different types of horizons, based on the number of periods and based on the duration of the periods.\nImplemented for EnergyModelsBase and EnergyModelsGeography.\nAllows for future value description through a new AbstractElement.\nUtilizes Accessors for faster parameter updating.\nSupports ParametricOptInterface through an extension.","category":"page"},{"location":"#EnergyModelsRecedingHorizon","page":"Home","title":"EnergyModelsRecedingHorizon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides a framework for receding horizon optimization of an energy system model. This package is developed as an extension to the multi carrier energy model EnergyModelsBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsRecedingHorizon follows the same philosophy with respect to extensibility as EnergyModelsBase. This means that users are able to implement new technologies as new nodes without changes to the core package structure. It may however be necessary to do minor adjustments to your existing nodes. This is the case if dynamic constraints are included in your node. An explanation of the required steps can be found in how to adapt an EMX element.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"manual/philosophy.md\",\n    \"manual/storage_end_value.md\",\n    \"manual/simple-example.md\",\n    \"manual/NEWS.md\",\n]\nDepth = 1","category":"page"},{"location":"#How-to-guides","page":"Home","title":"How to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"how-to/adapt-emx-elem.md\",\n    \"how-to/use-emrh.md\",\n]\nDepth = 1","category":"page"},{"location":"#Developer-notes","page":"Home","title":"Developer notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"dev-notes/code-structure.md\",\n    \"dev-notes/initialization.md\",\n    \"dev-notes/future_value.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"library/public.md\",\n    \"library/internals/types-EMRH.md\",\n    \"library/internals/methods-EMRH.md\",\n    \"library/internals/methods-EMB.md\",\n    \"library/internals/reference-POIExt.md\",\n    \"library/internals/reset.md\",\n]\nDepth = 1","category":"page"},{"location":"library/public/#lib-pub","page":"Public","title":"Public","text":"","category":"section"},{"location":"library/public/#lib-pub-idx","page":"Public","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#lib-pub-module","page":"Public","title":"Module","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"EnergyModelsRecedingHorizon","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon","page":"Public","title":"EnergyModelsRecedingHorizon","text":"Main module for EnergyModelsRecedingHorizon, a package that extends EnergyModelsX with the implementation of a receding horizon framework for stress testing the invested energy system in an operational framework.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#lib-pub-mod","page":"Public","title":"Model","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"RecHorOperationalModel\nrun_model_rh(case::AbstractCase, model::EMRH.RecHorEnergyModel, optimizer; check_timeprofiles::Bool=true)","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.RecHorOperationalModel","page":"Public","title":"EnergyModelsRecedingHorizon.RecHorOperationalModel","text":"struct RecHorOperationalModel <: RecHorEnergyModel\n\nOperational energy model without investments, receding horizon implementation.\n\nFields\n\nemission_limit::Dict{<:ResourceEmit, <:TimeProfile} is a dictionary with individual emission limits as TimeProfile for each emission resource ResourceEmit.\nemission_price::Dict{<:ResourceEmit, <:TimeProfile} are the prices for the different emissions types considered.\nco2_instance is a ResourceEmit and corresponds to the type used for CO‚ÇÇ.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.run_model_rh-Tuple{AbstractCase, EnergyModelsRecedingHorizon.RecHorEnergyModel, Any}","page":"Public","title":"EnergyModelsRecedingHorizon.run_model_rh","text":"run_model_rh(case::AbstractCase, model::RecHorEnergyModel, optimizer; check_timeprofiles::Bool=true)\n\nTake the variables case and model and optimize the problem in a receding horizon fashion as a series of optimization problems.\n\nwarning: Required input\nWhile the Case type is flexible, we have to follow certain structures.The case type requires as additional input in the dictionary field misc the entry :horizons corresponding to an AbstractHorizons type.\nThe order of the individual elements vector in the field elements cannot be arbitrary at the moment due to the structure of the code. You must use the following order:\nVector{<:EMB.Node}\nVector{<:Link}\nVector{<:Area}\nVector{<:Transmission}\nIf you do not use this structure, the model will not run.\n\nReturns results as a dataframe indexed by the model variables.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#lib-pub-hor","page":"Public","title":"Horizon","text":"","category":"section"},{"location":"library/public/#lib-pub-hor-typ","page":"Public","title":"Types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"DurationHorizons\nPeriodHorizons","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.DurationHorizons","page":"Public","title":"EnergyModelsRecedingHorizon.DurationHorizons","text":"DurationHorizons{T} <: AbstractHorizons{T}\n\nType used for specifiying the optimization and implementation horizon of a receding horizon model as the duration of the horizons. This implies that the number of operational periods in the different iterations can vary.\n\nIterating a DurationHorizons results in SingleHorizon which includes all information required for a single run.\n\nFields\n\nlen::Int64 is the total length of the investigated timeframe as a multiple of the duration of 1 of an operational period.\ndur::Vector{T} is a vector of the duration of each individual operational period.\noptim::Int64 is the sum of the duration of the operational periods that are used in the optimization horizon.\nimpl::Int64 is the sum of the duration of the operational periods that are used in the implementation horizon.\n\nnote: Optimization and implementation horizon\nThe optimization horizon corresponds to the horizon used in each individual optimization run while the implementation horizon must be shorter than the optimization horizon. This is enforced through an inner constructor. It corresponds to the operational periods extracted from the model run.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.PeriodHorizons","page":"Public","title":"EnergyModelsRecedingHorizon.PeriodHorizons","text":"PeriodHorizons{T} <: AbstractHorizons{T}\n\nType used for specifiying the optimization and implementation horizon of a receding horizon model as multiples of the number of periods.\n\nIterating a PeriodHorizons results in SingleHorizon which includes all information required for a single run.\n\nFields\n\nlen::Int64 is the total length of the investigated timeframe as a multiple of the duration of 1 of an operational period.\ndur::Vector{T} is a vector of the duration of each individual operational period.\noptim::Int64 is the number of operational periods that are used in the optimization horizon.\nimpl::Int64 is the number of operational periods that are used in the implementation horizon.\n\nnote: Optimization and implementation horizon\nThe optimization horizon corresponds to the horizon used in each individual optimization run while the implementation horizon must be shorter than the optimization horizon. This is enforced through an inner constructor. It corresponds to the operational periods extracted from the model run.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-hor-fcn","page":"Public","title":"Functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"durations\nindices_optimization\nindices_implementation","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.durations","page":"Public","title":"EnergyModelsRecedingHorizon.durations","text":"durations(single_hor::SingleHorizon)\n\nExtracts the fiels dur from the SingleHorizon single_hor corresponding to a vector of the durations of the individual time periods.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsRecedingHorizon.indices_optimization","page":"Public","title":"EnergyModelsRecedingHorizon.indices_optimization","text":"indices_optimization(single_hor::SingleHorizon)\n\nExtracts the fiels idx_optim from the SingleHorizon single_hor corresponding to a vector of the indices of the optimization horizon.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsRecedingHorizon.indices_implementation","page":"Public","title":"EnergyModelsRecedingHorizon.indices_implementation","text":"indices_implementation(single_hor::SingleHorizon)\n\nExtracts the fiels idx_impl from the SingleHorizon single_hor corresponding to a vector of the indices of the implementation horizon.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#lib-pub-init","page":"Public","title":"Initialization","text":"","category":"section"},{"location":"library/public/#lib-pub-init-typ","page":"Public","title":"Types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"AbstractInitData\nInitData\nStorageInitData","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.AbstractInitData","page":"Public","title":"EnergyModelsRecedingHorizon.AbstractInitData","text":"abstract type AbstractInitData <: EMB.Data\n\nAbstract type for initialization data.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.InitData","page":"Public","title":"EnergyModelsRecedingHorizon.InitData","text":"struct InitData{T} <: AbstractInitData\n\nInitialization data type for the inclusion of initial data before the first horizon. The standard initialization data is using a single value for a given variable. Multiple variables can be initialized simultaneously.\n\nFields\n\ninit_val_dict::Dict{Symbol,T} is a dictionary with the variable symbol as key and the value in the beginning of the analysis as value.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.StorageInitData","page":"Public","title":"EnergyModelsRecedingHorizon.StorageInitData","text":"StorageInitData(val::Real)\n\nConstructor for providing initialization for Storage nodes. A StorageInitData must be provided for each Storage node.\n\nArguments\n\nval::Real: initial value for storage level.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#lib-pub-init-fcn","page":"Public","title":"Functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"has_init(n::EMB.Node)\nis_init_data\ndata_init(n::EMB.Node)","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.has_init-Tuple{EnergyModelsBase.Node}","page":"Public","title":"EnergyModelsRecedingHorizon.has_init","text":"has_init(n::EMB.Node)\nhas_init(l::Link)\n\nChecks whether the node n or link l has initialization data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnergyModelsRecedingHorizon.is_init_data","page":"Public","title":"EnergyModelsRecedingHorizon.is_init_data","text":"is_init_data(data)\n\nChecks whether the argument data has initialization settings.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsRecedingHorizon.data_init-Tuple{EnergyModelsBase.Node}","page":"Public","title":"EnergyModelsRecedingHorizon.data_init","text":"data_init(n::EMB.Node)\ndata_init(l::Link)\n\nReturns initialization data for node n or link l.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#lib-pub-fut_val","page":"Public","title":"Future value","text":"","category":"section"},{"location":"library/public/#lib-pub-fut_val-typ","page":"Public","title":"Types","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"FutureValue\nElementValue\nStorageValueCuts\nStorageValueCut","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.FutureValue","page":"Public","title":"EnergyModelsRecedingHorizon.FutureValue","text":"abstract type  FutureValue <: AbstractElement\n\nDeclaration of the abstract type for future value descriptions in the optimization.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.ElementValue","page":"Public","title":"EnergyModelsRecedingHorizon.ElementValue","text":"struct ElementValue{T<:Union{TimeProfile, Real}}\n\nAn ElementValue represents an instance of a given AbstractElement with an assigned value. It replaces dictionaries in which an AbstractElement is used as key value so that it is possible to reset the AbstractElement\n\nFields\n\nelement::N is the instance of the element.\nvalue::T is the used value.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.StorageValueCuts","page":"Public","title":"EnergyModelsRecedingHorizon.StorageValueCuts","text":"struct StorageValueCuts <: FutureValue\n\nA collection of multiple StorageValueCut that constructs a piecewise linear upper one the future value of the stored resource.\n\nFields\n\nid::Any is the name/identifier of the StorageValueCuts.\ntime::Int is the time where the cut is valid relative to the start of the operational period.\nweight::Real is the weighting of the StorageValueCuts in the objective function. For example used if the end time of the optimization arrives between two different StorageValueCuts.\ntime_weight::Real is the weighting of the StorageValueCuts in the objective function due to the elapsed time.\ncuts::Vector{StorageValueCut} is a vector of all the cuts that are included in the future value description.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsRecedingHorizon.StorageValueCut","page":"Public","title":"EnergyModelsRecedingHorizon.StorageValueCut","text":"struct StorageValueCut\n\nA StorageValueCut represents a cutting hyperplane that puts an upper bound on the value of the stored resource at the end of the optimization horizon.\n\nFields\n\nid::Any is the name/identifier of the StorageValueCut.\ncoeffs::Vector{<:ElementValue} are the cut coefficients associated with the level of the given Storage nodes. They can also be provided as Dict{<:Storage{<:Accumulating}, <:Real}.\nrhs::Real is the cut right hand side constant.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-fut_val-fcn","page":"Public","title":"Functions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"get_future_value\nhas_cuts","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.get_future_value","page":"Public","title":"EnergyModelsRecedingHorizon.get_future_value","text":"get_future_value(ùí≥·µõ·µâ·∂ú::Vector{Vector})\nget_future_value(case::Case)\nget_future_value(ùí∞::UpdateCase)\n\nReturns the vector of FutureValue of the Case case or the vector of elements vectors ùí≥·µõ·µâ·∂ú.\n\nIf the input is an UpdateCase, it returns the new FutureValuess of the individual FutureValueSub types of UpdateCase ùí∞.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#EnergyModelsRecedingHorizon.has_cuts","page":"Public","title":"EnergyModelsRecedingHorizon.has_cuts","text":"has_cuts(v::FutureValue)\nhas_cuts(v::StorageValueCuts)\n\nReturns true if the FutureValue is of type StorageValueCuts.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#lib-pub-misc","page":"Public","title":"Miscellaneous","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"RecedingAccumulating","category":"page"},{"location":"library/public/#EnergyModelsRecedingHorizon.RecedingAccumulating","page":"Public","title":"EnergyModelsRecedingHorizon.RecedingAccumulating","text":"struct RecedingAccumulating <: Accumulating\n\nStorageBehavior which accumulates all inflow witin a strategic period. RecedingAccumulating allows for initializing level values for the storages.\n\n\n\n\n\n","category":"type"}]
}
